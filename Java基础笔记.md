# 基础第一天

#### Java背景

sun 1995 高级编程语言 詹姆斯-高斯林

2009 Oracle收购

SE标准版

EE企业版

ME小型版

#### 命令

1. cmd
   - cd： 切换目录
   - dir： 显示盘符里的文件
   - C:  进入C盘根目录 （盘符:）
   - cls： 清屏
2. java
   - javac： 编译命令
   - java： 执行命令

#### JDK组成

- JVM： Java虚拟机，真正运行Java程序的地方
- 核心类库： 是Java提前写好的程序，可以直接使用
- JRE：Java运行环境（由JVM和核心类库组成）
- 开发工具： Java，Javac

#### 字面量

​		指变量的值及在程序中书写格式（整数如 10，字符如 ‘a’ ）

- 整数： int（整数常量）
- 小数： double float（小数常量）
- 字符： char 使用单引号且引号中只有一个字符，不可为空  ‘c’（字符常量）
- 字符串： String 使用双引号可以为空  ”“（字符串常量）
- 布尔： boolean 值为true和false（布尔常量）

#### 变量

​	是内存中的一块区域，用于存储一个数据，且存储的数据可以被替换

- 先声明在使用
- 在一对{}中有效，不能定义同名变量
- 定义时可以不赋初值，使用前必须赋值

#### 关键字

​	Java语言已经定义好的名称，并且赋予相应的功能；标识符定义时不可以使用关键字

#### 标识符

​	就是名字

- 由数字，字母，下划线_，美元符$组成
- **不能以数字开头，区分大小写，不能是关键字**



# 基础第二天

#### 字节（byte，B）

​	一个字节等于8个**位（b）**  8b=1(B)byte

​	计算机最小组成单元是**字节**

#### ASCII

​	A=65，a=97，0=48

#### Java中进制写法

- 二进制以 0B或0b
- 八进制 0
- 十六进制 0X或0x

#### Java数据类型

​	分为**引用数据类型**和**基本数据类型**

- 整数
  - byte         -128(-2^7)~127(2^7-1)                     占用1字节（B）
  - short       -32768(-2^15)~32767(2^15-1)        占用2字节（B）
  - int             (-2^31)~(2^31-1)                              占用4字节（B）
  - long          (-2^63)~(2^63-1)                              占用8字节（B）     （末尾加L/l）
- 浮点
  - float        1.401298e-45到3.402823e+38       占用4字节（B）     （末尾加F/f） 保留小数6位
  - double  4.9000000e-324 到1.797693e+308 占用8字节（B）                               保留小数14位
- 字符
  - char        0-65535                                              占用2字节（B）
- 布尔型
  - boolean             true false（字面量，不是关键字）                                占用1字节（B）

#### 自动类型转换

​	小范围变量可以直接赋值给大范围变量

​	byte、short、char是直接**转换成int类型**来运算

​	表达式的最终类型为表达式中的最高类型来决定

1. 如果表达式中出现double类型，则结果一定是double
2. 如果表达式中出现float类型没有double类型，则结果一定是float
3. 如果表达式中没有float类型也没有double类型但出现long类型，则结果一定是long

#### 强制类型转换

​	范围大的变量赋值给范围小的变量，**需要强制转换**

写法：数据类型1 变量名1 = （数据类型1）变量名2；

#### 运算符

- 基本算术运算符

  - +加
  - -减
  - *乘
  - /除  整数除整数**取整数**
  - %取余

- 自加自减运算符

  - ++ 自加一
  - --   自减一
  - ++ --只能操作变量，不能操作字面量；可以放在变量前面（先加后用）或者后面（先用后加）

- 字符串连接符（+）

  用于字符串之间的连接；能算就算，不能则连接

- 赋值运算符（=）

  将右边的数据赋值给左边的变量

  - +=  a+=b 等价于a=（a的数据类型）（a+b）
  - -=
  - *=
  - /=
  - %=

- 关系运算符

  返回一个真假值（true和false）

  - ==
  - <=小于或等于;  >;   >=;  >;  
  - !=

- 逻辑运算符

  - & 与  全真为真，有假为假
  - | 或   有真为真，全假为假
  - ！非  取反   真为假（!true），假为真（!false）
  - ^ 逻辑异或  相同为假，不同为真
  - && 短路与  左边有false则右边不执行
  - ||  短路或  左边有true则右边不执行

- 三元运算符

  条件表达式？true（值）：false（值）

- 运算符优先级

  看图 - 运算符的优先级.jpg
  
- (1+2)>>>1

  ```
  （1+2） >>> 1右移一位就是除以2的1次方
  
  （1+2） >>> 2右移一位就是除以2的2次方
  ```

  

# 基础第三天

#### 程序流程控制

##### 顺序结构：自上而下执行

##### 分支结构：根据条件，选择对应分支执行代码

- if分支：根据条件（真或假）为真则执行if分支中的代码，否则执行else中的代码   

  ```java
  if ( 条件表达式 ){
      代码块 
  }else{ 
      代码块
  }
  ```

- if（）{} else if（）{} else{}：elseif分支  **多分支**  

- **注意：只要有一个if分支执行了，剩下的都不会执行**

- switch分支：case值得类型可以是byte，short，char，int，enum(**JDK5**)，String(**JDK7**后才支持) ；必须为字符串常量或者字面量

  ```java
  switch(表达式){
  	case 值 : 
  	代码块;
  	break;//无break表示穿透
      .... 
      default:
      代码块n;
  }
  ```

- **建议：区间匹配使用if，值匹配使用switch**

##### 循环结构：重复执行某段代码

for循环：

```java
for(初始化语句;循环条件;迭代语句){
	循环代码块
}
//执行顺序：初始化语句 -> 循环条件（为真执行循环代码块）（为假结束循环） -> 循环代码块 -> 迭代语句 —> 循环条件
```

while循环：

```java
初始化语句;
while(循环条件){
	循环代码块;
	迭代语句;
}
```



do-while循环：

```java
初始化语句;
do{
	循环代码块;
	迭代语句;
}while(循环条件);
```

##### 跳转控制语句

- break：跳出并结束当前循环
- continue：跳出本次循环，进入下一次循环
- return：立即跳出并结束当前方法

#### Random

生成随机数

**生成65-91之间的数**

1. 91-65=26
2. 调用nextInt(27)+65则生成65-91之间的数

# 基础第四天

#### 数组

​	是用来存储同一批同种类型数据的容器

##### 数组的内存图

- Java内存分配
  - **方法区**（字节码文件加载时进入的内存，方法初始化也在这里）>>> **栈内存**（方法运行时所进入的内存，变量也是在这里）>>> **堆内存**（new出来的东西会在这块内存中开辟空间并产生地址）

#### 数组的定义

##### 静态初始化数组

- 标准写法：数据类型[] 数组名 = new 数据类型[]{元素1，元素2，...，元素n}；
- 简化写法：数据类型[] 数组名 = {元素1，元素2，...，元素n}；
- **注意：数组变量名中存储的是数组在内存中的地址，数组是引用类型**

##### 动态初始化数组

- 数据类型[] 数组名 = new 数据类型[数组长度]

###### 数组的索引

- **数组名[索引值]**
- 索引值 = 0 ~ length-1
- 获得数组长度：数组名.length 
  - **注：length是属性不是方法**
  - 最大索引值是：length - 1
  - 如果数组为空，则 length - 1 等于-1

###### 使用问题

1. 访问索引超过最大索引，则会抛出**数组索引越界异常**（ArrayIndexOutOfBoundsExeption）
2. 如果数组变量存储的是null，再访问数值元素（array[i]）时则会抛出**空指针异常**（NullPointerException）

##### 元素默认值规则

| 数据类型 |             明细             | 默认值 |
| -------- | :--------------------------: | :----: |
| 基本类型 | byte、short、char、int、long |   0    |
| 基本类型 |        float、double         |  0.0   |
| 基本类型 |           boolean            | false  |
| 引用类型 |    类、接口、数组、String    |  null  |

# 基础第五天

#### 方法

​	是一种语法结构，它可以把一段代码**封装成一个功能**，**以便重复调用**

​	不能提高代码效率，但可以**提高代码复用性**

```
修饰符 返回类型 方法名(形参列表){
	方法体;
	return 返回值;
}
```

##### 方法的常见问题

- 方法的编写顺序**先写后写都一样**
- 方法与方法之间是平级关系，**不能再方法体内定义新方法**
- void(无返回值)方法则可以不需要写return
- return语句下面不可以写代码，属于**无效代码**(永远执行不到)
- 调用时必须**严格匹配方法**的参数列表；方法**不调用**就不执行
- 调用有返回值的方法可以直接调用输出结果(**sout(方法名)**)，也可以定义变量结束结果在输出；**无返回值只能直接调用**

##### 方法的调用流程

- 方法放在方法区中，**被调用时**，需要进入到**栈内存**中运行
- **注**：当java文件编译后，生成class文件，（字节码文件和方法进入方法区）**方法区**中包含**class字节码**、方法，开始**执行时main方法**进入栈内存中（**先进后出机制**），main方法中的**变量**，存在于**栈内存**中，先调用的方法先进入栈内存，执行完成后出栈，如果调用方法中又调用了其他方法，其他方法再入栈，其他方法执行完成后出栈，再依次执行、调用。**后调用先出栈**

##### 方法的参数传递机制

- 实参：在调用方法内部定义的变量
- 形参：是方法定义时的变量**(方法名后括号中的参数)**
- 在**基本数据类型**中实参传给形参时，采用值传递**(数据值)**
- 在**引用数据类型**中实参传给形参时，采用值传递**(地址值)**

##### 方法的重载（overload）

​	指在同一个类中，出现多个同名方法，但形参不同（**类型，个数，顺序**），那就是重载

注：调用时会**按照参数**不同来**区分调用**的**是哪个方法**

###### 重载的作用

- 可读性好，方法同名提示同一种类型的功能，通过形参不同来实现功能的差异化，这是一种专业的代码设计

##### 方法的重写

参数列表必须与被重写方法相同

返回类型必须相同

修饰权限不能比被重新方法小

不能抛出新的异常或者比被重写方法声明的异常更广的异常

# 基础第六天

#### 案例六个，看IDEA中的Day06模块中的Demo

# 基础第七天

#### 面向对象编程

​	面向对象编程的英文缩写是 OOP，全称是 Object Oriented Programming。

​	重要且基础的概念：**类（Class）和对象（Object）**

​	类：代表可以实现的一个具体**（是共同特征的描述（设计图））**

​	对象：代表调用的这个类，来实现这个类中的具体属性和方法**（是真实存在的具体实例）**

#### 什么是面向对象编程？

​	是一种编程范式或编程风格。它以类和对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性。作为代码设计和实现的基石

#### 什么是面向对象编程语言？

​	是**支持类和对象**的语法机制，并有现成的语法机制，能方便的**实现**面向对象编程**三大特性（封装，继承，多态）**的编程语言

封装、继承：增加代码的复用性  

多态：增加代码的可移植性，健壮性，灵活性

#### 如何设计类

```java
public class 类名{
	1.成员变量（类的属性）
	2.成员方法（类的行为）
	3.构造器
	4.代码块
	5.内部类
}
```

#### 定义类的注意事项

1. 命名满足驼峰模式
2. 一个Java文件中**只能有一个Public修饰的类**且**类名**和**文件名一致**；一个Java文件中可以定义多个类。
3. 属性无需指定初始值，存在**默认值**

#### 内存图

**方法区**加载class和main，main方法进入**栈内存**开始顺序执行；有**new构造器**则先将**new的类加载进方法区**然后开**辟一块堆内存**放此对象的**属性**，将此堆内存的**地址给main方法中的对象名**；类中的**成员方法是引用地址**（方法区中的）来**调用成员方法**

#### 构造器

初始化类的对象，并返回对象的地址

##### 注意事项

- 构造器名字和类名保持一致
- 构造器创建时不能有返回类型，void也不行
- 默认有一个无参构造器
- 如果定义了有参构造器，则默认无参构造器则没有了，必须自己手写一个无参构造器

#### this关键字

**代表当前对象的地址**，可以出现在构造器和方法中

##### 作用

- 用于访问当前对象的成员
- 解决命名冲突

#### 封装

面向对象的三大特征：封装、继承、多态

**好处：**让数据更安全，不对外直接暴露数据本身，同时也不需要对外暴露方法的实现细节

##### 封装的原则

对象代表什么，就得封装对应的数据，并且提供数据对应的行为

#### JavaBean

也成为实体类，其对象可以用于在程序中封装数据



##### 书写要求

- 成员变量使用private修饰
- 提供成员变量对应的 setXxx() / getXxx() 方法
- 必须提供一个无参构造器；有参构造器可写可不写
- 如果写了有参构造器则必须手写一个无参构造器

#### 成员变量和局部变量的区别

|     区别     |                  成员变量                  |                    局部变量                    |
| :----------: | :----------------------------------------: | :--------------------------------------------: |
| 类中位置不同 |                类中，方法外                |                  常见于方法中                  |
| 初始化值不同 |            有默认值,无需初始化             |        没有默认值，使用之前需要完成赋值        |
| 内存位置不同 |                   堆内存                   |                     栈内存                     |
| 生命周期不同 | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的运行结束而消失 |
|    作用域    |                                            |               在所归属的大括号中               |

# 基础第八天

#### String

为**不可以变字符串类型**，它的对象被创建后不可以更改

##### **常见问题**

- 初始赋值时的数据在堆内存中的字符串常量池**（相同内容只会存一份）**

- 所有**运算**得到的数据都**在堆内存中**
- String变量**每次修改**都是产生并指向了**新的字符串对象**；原来的字符串对象没有改变

##### 字符串比较

String推荐使用equals比较：因为只关心内容是否一样

equalsIgnoreCase：忽略大小写

**注：引用类型使用equals，基本数据类型使用 ==**

##### 常用API

|                            方法名                            |                             说明                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                   public int **length**()                    |                    返回此字符串的**长度**                    |
|              public char **charAt**(int index)               |               获取**某个索引**位置处**的字符**               |
|              public char[] **toCharArray**()：               |              将当前字符串**转换成字符数组**返回              |
|  public String **substring**(int beginIndex, int endIndex)   | 根据**开始和结束索引进行截取**，得到新的字符串**（包前不包后）** |
|         public String **substring**(int beginIndex)          |    从传入的索引处截取，**截取****到末尾**，得到新的字符串    |
| public String **replace**(CharSequence target, CharSequence replacement) |      使用新值，将字符串中的旧值**替换**，得到新的字符串      |
|           public String[] **split**(String regex)            |       根据传入的规则**切割**字符串，得到字符串数组返回       |
|              public int **indexOf**(String str)              |     **返回指定**子字符串第一次出现的字符串内的**索引**。     |

#### 集合

与数字类似，也是一种容器，用于装数据

- 大小不固定，启动后可以动态变化，类型也可以选择不固定
- 适合做元素个数不确定，且要进行增删操作的业务场景

##### ArrayList

是集合的一种，它支持索引

##### 泛型概述

ArrayList<E>其实就是一种泛型类，可以在编译阶段约束集合对象只能操作某种数据类型。

**泛型擦除：就是泛型只存在于编译阶段，运行阶段就不存在泛型了**

**注意：泛型只能支持引用数据类型，不支持基本数据类型。**

###### **举例：**

1. ArrayList<String> ：此集合只能操作字符串类型的元素。
2. ArrayList<Integer>：此集合只能操作整数类型的元素。

# 基础第九天

#### ATM系统

# 进阶第一天

### 继承

指在一个现有的基础上构建一个新的类，构建出来的新类被称作为子类，现有类被称作父类，**子类**会自动拥有**父类**所有**可继承（非私有）的属性和方法**

##### 格式

关键字：extends

```java
class 父类名{

}

class 子类名 extends 父类名{

}
```

##### 继承中成员变量的访问特点（default修饰）

- 子类父类成员变量**不重名**
  1. 类外访问：通过创建子类对象来访问**（子类有就访问子类，没有就访问父类，否则报错）**
  2. 类中访问：在子类中通过方法进行访问**（通过this访问）**
- 子类父类成员变量**重名**
  1. 类外访问：通过创建子类对象来访问（**默认访问子类，无法访问父类**）
  2. 类中访问：在子类中通过方法进行访问父类重名成员变量**（通过super访问父类）**

#### 继承在内存中的创建顺序

编译字节码文件并开始执行后，class文件进入方法区，main方法中执行到new构造器时，在堆内存创建一个该类对象，如果该类继承一个父类，则在对象中创建一块super区域来代表继承父类的成员变量和成员方法，最后创建子类成员变量和成员方法。

##### 继承中成员方法的访问特点

- 成员方法不重名
  1. 类外访问：子类有就访问子类，没有就访问父类
  2. 类中访问：直接调用
- 成员方法重名（方法重写）
  1. 类外访问：默认访问子类，无法访问父类
  2. 类中访问：通过super访问父类方法

- **注：方法重写**
  1. 必要条件：方法名和参数列表（包括列表顺序）、返回值类型必须相同
  2. 可选条件：修饰符类型（大于等于父类修饰权限）、抛出异常不能大于被重写的异常、可以不同
  3. 为何重写：当父类的方法逻辑满足不了子类的需求时重写

##### 继承中构造方法的访问特点

- 子类无法继承父类的构造方法
- 子类初始化过程中，子类的构造方法默认先调用父类无参构造方法

###### 继承的好处

- 减少编码，提高代码的复用性
- 让类与类之间产生关系
- 继承是多态的前提

###### 继承的注意事项

Java中类与类之间的继承，只可以单继承，不允许多继承，但可以多层继承

# 进阶第二天

### 接口与多态

#### 抽象类

把不够具体的，但子类要有的功能，在父类中声明为抽象方法，此时的类必须是抽象类

#### 什么是抽象类

抽象法方法所在的类就是抽象类

#### 什么是抽象方法

**没有方法体的方法就是抽象方法**

```java
public abstract 返回类型 方法名();  // 对
public abstract 返回类型 方法名(){} // 错
```

##### 父类抽象方法存在的意义

是同种事物不同对象所共同拥有的特征但各对象实现逻辑不同的描述，增加了代码复用性，灵活性

**抽象类不能创建对象（不能new）（抽象类的存在的所有情况都是作为父类而存在的）**

##### 关键字：

abstract

##### 定义：

###### 命名规范：以Abstract开头

```
public abstract 返回值类型 方法名(); // 抽象方法定义
public abstract class 类名{}		 // 抽象类定义
```

#### 抽象类和抽象方法的使用

子类继承抽象类必须实现抽象类的所有抽象方法，或者子类也是抽象类

#### 接口

是对外暴露的一套规则/规范，遵守了规范就能具备指定的功能

- 接口中定义的方法默认是public
- 实现类/子类实现了接口就必须重写接口中的抽象方法

##### 定义：

```java
public abstract interface 接口名{} // 完整格式
public interface 接口名{}			// 简化格式
```

##### 使用：

```java
public class 实现类/子类 implements 接口名{}
```

##### 接口中的方法

```java
1.抽象方法
	public abstract 返回值类型 方法名();
2.默认方法
	public default 返回值类型 方法名(形式参数){方法体;}
3.静态方法
4.静态变量
```

- **默认方法可以只需要实现的类来重写（子类有需求可以主动实现）**
  1. 如果**重写**默认方法则执行重写逻辑
  2. 如果**没有重写**默认方法则执接口逻辑
- 抽象方法必须实现

##### 接口存在的意义

- 接口：是某个接口具备了某种行为，和事物是什么没关系，所有事物都可以实现
- 抽象类：是这个抽象类事物具备了某种行为，只能这个这个事物来实现

###### 引用数据类型（类/接口/枚举/数组）

#### 多态

同一种事物的多种形态

**Java中的多态：同一个对象，在不同时刻表现出来的不同形态**

##### 多态的满足条件

1. 有继承或者实现关系（实现接口）
2. 有方法重写（子类重写父类的方法）

##### 多态的宏观体现

1. 父类引用指向子类对象

2. 接口引用指向实现类对象

   ```java
   1. 父类 对象名 = new 子类();
   2. 接口类型 对象名 = new 实现类/子类()
   ```

##### 多态的访问特点

1. 成员变量：编左看左（编译阶段看左边是否具备该变量，运行时会获得左边成员变量）
2. 成员方法：编左看右（编译阶段看左边是否具备这个方法，运行时运行指向子类对象（实现类）的方法）

##### 多态的微观体现

1. 形式参数：当形参是一个父类或接口时，传递实参时可以是该类/接口任意子类/实现类
2. 返回值：返回值类型为父类或接口时，可以返回子类对象或者实现类对象

##### 多态的好处

提高代码的复用性和灵活性、拓展性

##### 多态的向上转型

父类或接口引用指向子类或实现类对象

```
父类类名 变量名(引用变量) = new 子类类型();
```

##### 多态的向下转型

父类或接口引用转换成子类对象

```
子类类名 变量名 = （子类类名）父类引用;
```

**可以使用子类的特有方法**

##### instanceof

**变量名 instanceof 类名** =》返回一个boolean值，判断引用/变量当前指向的对象是否是右边类型的对象，如果是返回一个true，否则false

#### Java中的三大关系

1. 类与类：继承，单继承，不可以多继承

2. 类与接口：接口，一个类可以实现多个接口

3. （2+1）一个类在实现接口的同时也可以继承

4. 接口和接口：一个接口可以继承多个其他接口 

   ```java
   1. public class 类A extends 类B{}
   2. public class 类A implement 接口C,接口D{}
   3. public class 类A extends 类B implement 接口C{}
   4. public interface 接口A extends 接口B,接口C{}
   ```

# 进阶第三天

### 修饰符

##### final关键字

表示不可更改。用于修饰类、方法和变量。

1. 类：被修饰的类不能被继承

2. 方法：被修饰的方法，不能被重写

3. 变量：被修饰的变量，不能被重新赋值

   1. 在**方法参数**上**基本类型**被final修饰，不能再次赋值

   2. 在**方法内部修饰**的**局部变量**，不能进行二次赋值

      ```
      final int a;
      a = 10;// 可以  只能赋值一次
      a = 20;// 错误  不能二次赋值
      ```

   3. **引用类型**被final修饰时，引用变量**不能再指向其他对象**，**地址值不能更改**，**但引用变量是可以修改对象中的属性**

   4. **成员变量**被final修饰时，

      1. 定义未赋值时：**构造方法必须完成对final变量的赋值**；所有**成员方法不能修改final修饰的变量的值**
      2. 定义并赋值：所有构造方法、成员方法中不能修改final修饰的变量的值。
      3. 不提供set方法设置final成员变量

注：final不能和abstract一起使用；final修饰的变量也叫**自定义常量**

##### 命名规则

全驼峰命名：全大写

```
final int MAX_ONE = 10;
```

#### 权限修饰符

| 权限修饰符 | 说明                                      |
| ---------- | ----------------------------------------- |
| public     | 公共的                                    |
| protected  | 受保护的                                  |
| default    | 默认的（不写，不加权限修饰符就是default） |
| private    | 私有的  //                                |

|              | public | protected | default | private |
| :----------: | :----: | :-------: | :-----: | :-----: |
|     同类     |   ✔    |     ✔     |    ✔    |    ✔    |
|  同包不同类  |   ✔    |     ✔     |    ✔    |    ✘    |
| 不同包子父类 |   ✔    |     ✔     |    ✘    |    ✘    |
| 不同包非继承 |   ✔    |     ✘     |    ✘    |    ✘    |

**成员变量**推荐使用**private**，并提供get/set方法（**get/set方法是为了可视化数据赋值，避免非法数据赋值**）

```java
public void setName(String name){
	char[] newName = name.toCharArray();
	int index = 1;
	for(int i = 0;i < newName.length;i++){
		if(newName[i] > '0' && newName[i] < '9'){
			index = -1;
		}
	}
	if(index == 1){
		this.name = name;
	}else{
		sout("请输入不带数字的名字！");
	}
}
```

**构造方法**推荐使用**public**，方便任意类创建

#### static关键字

被该类的所有对象共享使用，不依赖于某个对象，与对象无关，依赖于类，在内存中唯一只有一份

##### 类加载的过程

**第一个次使用**时，首先检查class文件是否被加载到方法区，如果没有则把该类的**class文件加载到方法区**（此时还没有对象），如果class文件中**有static静态修饰的内容**，会把**static修饰的内容加载方法区的静态区中**，**并且要完成静态成员的初始化**，然后进行对象的创建

##### static特点

- 被static修饰的成员=》属于类成员=》不属于对象
- 被static修饰的成员会跟着类的加载而加载
- 由于对象必须等着类加载到内存，才可以new，而static随着类走，所以static的成员优先于对象存在
- 只要是根据static所在类创建出来的对象，都可以共享这个static修饰的成员

##### 使用

通过类名.静态成员变量名称

也可以通过累的实例对象.静态成员变量名称（**不推荐**）

通过类名.静态成员方法名称

##### 注意事项

1. 静态中不能使用非静态
2. 静态的内容，是**最先被加载到**内存方法区中的**静态区**中，并完成初始化，但是**此时没有对象**（**非静态的内容存在于对象中**）既然没有对象，**就不能使用非静态的内容**
3. 静态（先人），非静态（后人）
4. **静态方法可以直接访问静态变量和静态方法**
5. 静态方法不能直接访问非静态成员变量或成员方法（**通过new对象后 ，对象名.方法或属性**）
6. 反之，成员方法可以直接访问方法静态变量或静态方法
7. 静态方法中不能使用this关键字

##### 静态代码块

使用{}叫做代码块，加上static叫做静态代码

```
static{
	代码块;
}// 静态代码块

{
	代码块;
}// 代码块也叫构造代码块 编译到class文件中就是在每个构造方法中
局部代码块{
	代码块；
}// 在方法内部作用，控制生命周期
```

###### 特点

1. 静态修饰的代码（如静态代码块、静态成员变量）最先运行（创建），其次代码块，最后构造方法
2. 如果只创建对象，静态代码块会优先于构造方法执行，**唯一执行一次**
3. 静态代码块，**随着类的加载而加载**并唯一执行一次
4. **完成静态成员变量的赋值**
5. 静态代码块，仍然属于静态内容，**内部不能使用非静态**
6. **完成项目的初始化**
7. main方法再哪类中，哪个类的静态方法块就先执行

##### 代码块

控制生命周期；每次new 构造器时都会执行

##### 执行流程

1. 第一次创建：静态代码块 =》代码块 =》构造方法
2. 第二次创建：代码块 =》构造方法

# 进阶第四天

#### 内部类

一个东西（外部类）内部包含了一个或多个东西（内部类）

##### 格式

```java
外部类.内部类 对象名 = new 外部类().new 内部类(); //普通内部类
外部类.内部类 对象名 = new 外部类.内部类(); // 静态内部类
内部类 对象名 = new 内部类();// 静态内部类简写
```

##### 静态内部类

静态内部类要被外部类中的静态方法访问

```java
// 在class文件中的静态内部类
class Demo$Nei {
    private String name;

    public Demo$Nei() {
        System.out.println("内部类代码块");
        System.out.println("内部类构造方法");
    }

    public Demo$Nei(String name) {
        System.out.println("内部类代码块");
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    static {
        System.out.println("内部类静态代码块");
    }
}

// 在class文件的普通内部类
public class Fu$Nei {
    private String name;

    public Fu$Nei(Fu this$0) {
        this.this$0 = this$0;
        System.out.println("Fu.Nei内部类代码块");
        System.out.println("Fu.Nei内部类构造方法");
    }

    public Fu$Nei(Fu this$0, String name) {
        this.this$0 = this$0;
        System.out.println("Fu.Nei内部类代码块");
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

##### 静态内部类和普通内部类区别

1. 文件名为外部类名$内部类名
2. **静态内部类**构造方法**没有外部类的形参**，**普通内部**类构造方法**则有**外部类形参

##### 特点

内部类可以直接使用外部类的所有内容，但外部类想要访问内部类需要创建内部类对象后访问。

##### 执行流程

1. 第一次创建：静态代码块 =》代码块 =》外部类构造方法 =》内部类代码块 =》内部类构造方法
2. 第二次创建：代码块 =》外部类构造方法 =》内部类代码块 =》内部类构造方法

##### 定义

1. 成员内部类：定义在外部类的**成员位置**（与成员变量和方法同级）可以使用**public、private、static修饰**
2. 局部内部类：定义在外部类的**方法内部**，该内部类出了方法就没有用了

##### 匿名内部类

是内部类的简化写法。只能使用一次，是实现父类或接口的子类或实现类对象

作用：

1. 是创建接口实现类对象的快捷方式。把创建实现类，重写抽象方法，创建实现类对象，实现类对象调用方法**四步合成一步完成**
2. 是创建抽象父类的子类对象的快捷方式

###### 格式

```java
new 抽象父类/接口(){
	重写所有抽象方法
}

// class文件的命名
// 外部类名$序号.class
```

##### 类作为返回值和方法参数

- 作为形参和返回值：传递的**都是实例对象的地址值**

##### 抽象类作为返回值和方法参数

- 作为形参和返回值：传递的是**子类的实例对象的地址值**

##### 接口作为返回值和方法参数

- 作为形参和返回值：传递的是**实现类对象的地址值**

#### API

##### Object

是所有类的父类，自己定义的类默认继承Object

##### 为什么所有类都继承Object？

Java开发者认为每一个类都应该具备一些指定的行为，而这些行为可以定义在Object中

##### toString()

方便查看对象的内容

getClass().getName()：全限定类名（包名 + 类名）

为什么重写toString()：当通过输出语句打印对象时，底层默认打印的对象调用的toString的结果（对象名.toString()）

##### equals()

每一个对象都具备的一个功能，来和其它对象通过内容进行对比，而不是地址值 

对比对象的内容，而不是对比地址值

为什么重写equals()：需要一种通用的对引用数据类型对象进行对比的方法，我们想要对比的是内容，但Object底层还是 == 进行对比。

##### Date类

是Java提供的一个时间类，用于表示一个精确的时间点	

##### DateFormat类

格式化时间的抽象类，使用**SimpleDateFormat**来格式化Date时间

| 标识字母 |            |
| -------- | ---------- |
| y        | 年（yyyy） |
| M        | 月（MM）   |
| d        | 日（dd）   |
| H        | 时（HH）   |
| m        | 分（mm）   |
| s        | 秒（ss）   |

```java
SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
```

**parse(String str)**从字符串中解析文本并产生一个Date对象，根据字符串的年月日获得到时间原点（传递字符串，解析并返回字符串里代表的日期对象）

**format(Date time)**传递日期对象，返回格式化后的字符串

**getTime()**获得到时间原点的毫秒值

```java
		SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd");
        System.out.println("请输入你的生日：");
        String str = new Scanner(System.in).nextLine();
        Date birthdayDate = s.parse(str);
        System.out.println(birthdayDate);
        Date now = new Date();
        long aliveTime = now.getTime() - birthdayDate.getTime();
        System.out.println(aliveTime / 1000 / 60 / 60 / 24);
        System.out.println(s.format(now));
        System.out.println("==============");
        SimpleDateFormat s2 = new SimpleDateFormat("yyyy/MM/dd");
        Date noww = new Date();
        System.out.println(noww);
        // 根据字符串格式设置获得年月日获得到时间原点
        Date parse = s2.parse("1999/1/2");
        System.out.println(parse);
        System.out.println((noww.getTime() - parse.getTime()));

```

##### Calendr类

是一个日历抽象类，JDK1.1出来的，为了弥补Date类的缺陷

**get(int field)** 出入日期字段获得相应的值

**set()**设置时间日历

**add()**增加或减少日期

**setTime()**  Date转Calendar

**getTime()**  Calendar转Date

```java
		Calendar c = CalendargetInstance();
		int year = c.get(Calender.YEAR);
		int month = c.get(Calender.MONTH)+1;// 要+1 从0开始

		Calendar calendar = Calendar.getInstance();
   	    System.out.println(calendar.get(Calendar.YEAR));

        calendar.set(Calendar.YEAR,2000);
        System.out.println(calendar);

        calendar.add(Calendar.YEAR,+3);
        System.out.println(calendar);

        calendar.add(Calendar.YEAR,-1);
        System.out.println(calendar);

================================================
    
		System.out.println("请输入年：");
        int  year = new Scanner(System.in).nextInt();
        Calendar c = Calendar.getInstance();// 获取时间
        c.set(year,2,1);//设置日期为参数中的日期
        c.add(Calendar.DAY_OF_MONTH,-1);// 日减1
        int month = c.get(Calendar.DATE);
        if (month==28){
            System.out.println("今年是平年！共365天");
        }else{
            System.out.println("今年是闰年!共366天");
        }
        int sum = 0;
        for (int i = 0; i < 12; i++) {
            c.set(year,i+1,1);
            c.add(Calendar.DAY_OF_MONTH,-1);
            System.out.print(c.get(Calendar.DAY_OF_MONTH)+"\t");
            sum += c.get(Calendar.DAY_OF_MONTH);
        }
        System.out.println(sum);
```

##### System类

系统类，提供静态方法

# 进阶第5天

#### 二分查找

```java
	private static int forArrayIndxe(int[] old, int i) {
        int start = 0;
        int end = old.length-1;
        while(start<end){
            int mid = (start+end)/2;
            if (old[mid]>i){
                end = mid-1;
            }else if (old[mid]<i){
                start = mid+1;
            }else{
                return mid;
            }
        }
        return -1;
    }
```

#### Arrays类

专门操作数组的类

##### toString(数组对象){}

将传递的数组的内容按照指定的格式拼接为一个字符串

#### sort(数字类型的数组){}

将数组的内容排序

#### binarySearch(数组，目标值){}

按照二分查找的方法查询目标值在数组中的索引并放回

#### Math类

数学运算相关的工具类

##### abs(int value)

返回参数的绝对值

##### ceil()

向上取整

##### floor()

向下取整

##### round()

四舍五入（按小数的第一位进行参考）

##### max()

返回参数中的最大值

##### min()

返回参数中的最小值



#### BigDecimal类

是一个不可变对的，表示任意精度的十进制数据；一个对象表示一个数字；一个BigDecimal对象可以表示任意大的数据

##### 构造方法

```java
public BigDecimal(String value)
```

##### 成员方法

```java
//加：调用者与参数数据相加
//返回新的对象，不影响两个参与运算的对象值
public BigDecimal add(BigDecimal b)
//减：调用者与参数数据相减
public BigDecimal subtract(BigDecimal b)	
//乘：调用者与参数数据相乘
public BigDecimal multiply(BigDecimal b)
//除：调用者与参数数据相除
public BigDecimal divide(BigDecimal b)
//除加强：调用者与参数数据相除
//参数1；除数
//参数2：保留位数
//参数3：舍入模式（BigDecimal.ROUND_UP进1法：保留位数下一位不管是多少都会进1、BigDecimal.ROUND_DOWN去尾法：保留位数下一位不管是多少都会舍弃、BigDecimal.ROUND_HALF_UP四舍五入法：保留位数下一位进行四舍五入）
public BigDecimal divide(BigDecimal b，int scale，int roundingMode)
```

#### 基本类型与对应的包装类

| 基本类型 | 包装类    |
| -------- | --------- |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| char     | Character |
| boolean  | Boolean   |

##### 创建方式（装箱）

将基本数据类型转换为对应的引用数据类型

```java
Integer i = new Integer(10);// 不推荐
Integer i = Integer.valueOf(10); // 推荐
```

##### 拆箱

将对象转换为对应的基本数据类型

```java
int intValue();//Integer转int

Integer i = Integer.valueOf(10);
int i1 = i.intValue();

Double d = Double.valueOf(10.01);
int i2 = d.intValue();
double v1 = d.doubleValue();
```

##### 自动装箱

当Java系统发现某个地方的代码需要**基本数据**类型转变为**包装类**才可以操作的时候，则自动将**基本数据类型装箱为包装类型**

```java
Integer i = 10;//自动装箱
```

##### 自动拆箱

当Java系统发现某个地方的代码需要**包装类**转变为**基本数据**类型才可以操作的时候，则自动将**包装类型拆箱为基本数据类型**

```java
Integer i = 10(Integer.valueOf(10));
int ii = i + 20(i.intValue() + 20);//自动拆箱
// 底层就是
int ii = i.intValue() + 20;
```

##### String字符串与包装类的互相转换

```java
// String转Integer => 举一反三：需要转什么包装类就用什么引用类型的 valueOf() 方法
String number = "250";
Integer i = Integer.valueOf(number);
//String转int => 举一反三：需要转什么基本数据类型就用什么包装类的 pares基本数据名称() 的方法
int ii = Integer.paresInt(number);
//Integer转Sting
String s = String.valueOf(ii);
```

##### 包装类注意事项

###### 使用建议

- 正常运算的时候，能用基本类型就用基本类型
- 自定义实体类的成员变量时，使用包装类

###### 注意事项

- 如果实体类采用了包装类型作为成员变量，默认值为null，数组也是null

- Double类型必须使用小数赋值

- Integer类中有两个静态不可变成员变量：Integer.MAX_VALUE和Integer.MIN_VALUE

- Double类中有静态不可变成员变量（只有满足特性才会使用）

  ```java
  POSITIVE_INFINITY = 1.0 / 0.0;
  NEGATIVE_INFINITY = -1.0 / 0.0;
  NaN = 0.0d / 0.0;
  ```


###### 包装类面试题

- 直接通过构造方法创建的Integer对象，堆内存中创建

- valueOf构建的Integer对象值判断是否处于cache缓存区（-128 ~ 127）如果对象值不在这个缓存区中，则会在堆内存中创建新的对象

#### 异常Exception

程序在运行中出现的所用非正常的情况 =》通过一个类来描述对应的错误信息，通过异常对象来显示具体的某个异常；

Java中通过类来描述异常出现的原因，虚拟机就会创建该类的对象，用于描述本次出现异常的情况

##### 异常体系

1. Throwable
   1. Error（错误）一般是硬件
   2. Exception
      1. 编译异常（Exception）
      2. 运行异常（RunTimeException）

##### 异常出现的原因

 经过判断后不易在继续执行后，所出现的错误就是异常

##### 抛出异常的创建

```java
throw new 异常类型名();// 运行时异常

权限修饰符 返回值类型 方法名() throws 抛出的异常类型名{
    throw new Exception();
}// 编译时异常
```

##### 异常的处理

1. 不处理：向上抛：指在方法调用处声明异常

2. 捕获：

   ```java
   使用捕获异常
   try{
   	//可能出现的异常
   }catch(可能出现的异常类型 变量名){
   	//当出现异常并捕获后执行的逻辑
   }catch(可能出现的异常类型 变量名){
   	//当出现异常并捕获后执行的逻辑
   }finally{
       //try不管异常不异常，必执行
       //finall代码块中的返回值优先级：如果try和finally中都有返回值，则try的返回值先保存，最后返回finally的返回值
   }
   //不会影响后续代码的执行
   //try中的异常必须全部处理
   //捕获异常的顺序(先小后大,Exception兜底)
   ```

##### 自定义异常

明确：最终编写出来抛出的异常，是否是运行时异常还是编译时异常

###### 创建

```java
class 类名(ZiDingYiException) extends Exception或者RunTimeException{
    public 类名(){
        
    }
    public 类名(String message){
        super
    }
}
```

# 进阶第6天

### 集合

#### 对象数组

数组是容器，即可以存储**基本数据类型**也可以存储**引用数据类型**，存储了**引用数据类型的数组叫数组对象**（如：String[] , Person[]）

#### 数组和集合的区别

- 数组：
  1. 数组长度固定
  2. 数组的速度快于集合
  3. 能存储相同的数据类型（基本和引用都可以）
  4. 添加或修改数组需要创建新的数组
- 集合：
  1. 集合长度可变
  2. **只能存储引用数据类型**
  3. 有大量的方法可以直接操作（添加或者删除元素）集合

### Collection集合（集合根接口）

是一个接口，是所有单列集合的根接口

#### 单列集合

一次保存一个元素的集合

#### List子接口

特点：

- 有序：保证存入和取出的元素的顺序是一致的
- 有索引值：可以通过索引获得元素
- 可重复：可以存储多个相同元素

##### ArrayLsit集合

ArrayList无参构造默认的容量为0，会在第一次添加元素扩容为10，之后会按1.5倍扩容

特点：

- 有序，有索引，可以重复
- 底层数据结构：数组
- 查询快：有索引，元素内存空间连续
- 增删慢：数组长度不可变，需要凭创建新数组，拷贝元素，销毁旧数组
- 线程不同步，不安全，效率高

##### LinkedList集合

特点：

- 有序，有索引，可重复
- 底层数据结构：双向链表
- 查询慢：要么从前向后查询，要么从后向前查询
- 增删块：元素分配不连续，只需要找的位置，在修改对应节点保存地址的地方
- 线程不同步，不安全，效率高
- 有自有方法

  ```java
  public void addFirst();//在头结点添加元素
  public void addLast();//在尾结点添加元素
  public E getFirst();//在头结点获取元素
  public E getLast();//在尾结点获取元素
  public E removeFirst();//在头结点删除元素
  public E removeLast();//在尾结点删除元素
  ```

  

#### Set子接口

没有特有方法，基本上就是Collection接口的方法

特点：

- 无索引：不可通过索引获取元素
- 不可以重复：不可存储多个相同元素

##### 哈希值

哈希值就是通过哈希函数计算出来的一串数字

- 哈希函数能够将任意一个Java对象（10/100个属性）通过底层算法可以计算出来一串数字
- 哈希碰撞：完全不相同的两个对象通过哈希函数生成的哈希值一样（hashCode()返回的是一个int型，int是有限范围）

##### 哈希值创建原理

如果直接使用**Object类的hashCode方法**生成**哈希值**和对象内容无关，和**对象地址值有关**

IDEA**重写hashCode方法**后，生成哈希值则和**对象内容有关**（两个对象的**内容相同则**哈希值**一定相同**，但哈希值相同则对象内容不一定相同）

**注：重写hashCode()一定也要重写equals()**

​		为什么一起重写？

​		既要通过内容生成哈希值（可能哈希碰撞）也要通过内容来进行对比

##### HashSet集合中元素添加到哈希表的顺序

1. 当一个元素要添加到哈希表中的时候，首先会计算该元素的哈希值（重写的/继承Object的)哈希表并不关心
2. **明确**要添加的**元素被分配**到数组中**哪个索引中保存**：让元素的哈希值**对数组的长度取余**（0到长度减1）
3. 当明确分配的数组索引后，该索引中**没有**任何**元素**（**哈希表认为元素不重复**），元素作为**链表的头结点**
4. 如果分配的数组索引后，当中已经存在了链表，哈希表会使用本次元素的哈希值和该区域中已存在的元素的哈希值进行对比
5. 如果和该区域中的元素的哈希值**不相同**（**哈希表认为该元素不重复**）
6. 如果和该区域中的元素的哈希值**相同**（依然不能认为该元素重复，可能会有**哈希碰撞**）
7. 还会再调用**equals方法**和哈希值相同的**元素再次对比**，结果返回**true**（**该元素重复**），返回**false**则进行**保存**

##### Set集合保证元素唯一的方式

如果是自定义的元素，**一定要重写equals和hashCode方法**

##### HashSet集合

是实现Set接口的实现类，最常用的是Set集合

创建时会创建长度为16的集合

特点：

- 底层数据结构：哈希表（数组+链表/红黑树）
- 特点：增删查都快
- 无序：不保证存入和取出元素的顺序是一致的
- 无索引：不可通过索引的方式获取元素
- 不可重复：赖于hashCode和equals方法
- 线程不安去，不同步，效率高

**注：只要两个同类对象内容相同则为重复元素，和地址值无关**

##### LinkedHashSet集合

是HashSet的子类

特点：

- 底层数据结构：链表 + 哈希表
- 特点：查询速度快，增删也不慢
- **有序：保证存入和取出元素的顺序是一致的**
- 无索引：不可通过索引的方式获取元素
- 不可重复：赖于hashCode和equals方法
- 线程不安全，不同步，效率高

底层：同HashSet，另外

1. 也是同哈希表来保证元素唯一性，但是除了哈希表，内部还维护了一个链表
2. 当元素真正被添加到哈希表中，也会在链表中添加一份

弊端：多维护了一个链表，效率低，占用大

##### TreeSet集合

元素唯一/没有索引，但可以根据指定的规则进行排序

根据**排序规则**来**判断元素唯一**（当compareT**o方法返回值**为**0时**说明排序的元素属性值大小一样，所以这个值**不会添加**到集合中）**解决方法**：使用次要属性排序

TreeSet构造方法

无参构造：集合保存的元素必须实现Comparator接口

有参构造：集合保存的元素可以不实现Comparator接口，直接在构造方中实现Comparator



#### Collection集合的方法

所有实现Collection接口的集合都有的方法

| 方法名                                         | 说明                                 |
| ---------------------------------------------- | ------------------------------------ |
| public boolean add(E e)                        | 把给定的对象添加到当前集合的末尾     |
| public boolean addAll(Collection<? extends E>) | 将另一个集合元素添加到当前集合中     |
| public void clear()                            | 清空集合中所有的元素                 |
| public boolean remove(E e)                     | 把指定的对象在当前集合中删除         |
| public boolean contains(Object obj)            | 判断当前集合中是否包含给定的对象     |
| public boolean isEmpty()                       | 判断当前集合是否为空（没有任何元素） |
| public int size()                              | 返回集合中的元素个数                 |
| public T[] toArray(T[] t)                      | 把集合中的元素，存储到数组中         |

- 如果集合中保存的是自定义的元素，**通过remove删除**自定义元素，则**自定义元素**所在的类一定要**重写equals方法**，否则只会根据地址对比；**remove**默认**只删除第一次对比成功的值**（对比成功后直接返回true），

**注：remove()和contains()参数是一个对象，而不是某个成员属性**

#### 迭代器（Iterator）

遍历集合中的所有元素

1. 获得Iterator对象
   1. public Iterator iterator()  获得集合对应的迭代器，用来遍历集合中的元素
2. Iterator接口中的常用方法
   1. public E next()   返回迭代的下一个元素
   2. public boolean hasNext()  如果仍有元素，则返回true，继续迭代
   3. public void remove(): 是迭代器的删除方法

###### 注意事项：

- 不要在一次hasNext()循环中使用多次next()方法
- hasNext方法和获取元素next方法没有必然关系，如果**不在循环**中**使用next获取方法**，则hasNext一直**返回true**，成为**死循环**
- 在迭代的过程中**不可以**使用集合对象**调用任何**会**对**集合**长度进行修改的方法**
  - 解决办法：使用迭代器的方法
    - 添加在迭代外面添加
    - 删除使用迭代器的remove

```java
//Iterator源码
    
		public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)  // 为什么加入这个判断？答：在一次循环中可以调用多次next()方法
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }
```



#### 数据结构

数据用什么样的方式在内存中存储

在内存中组织数据的方式（保存的方式）

数据存储的常用结构有：栈、队列、数组、链表和红黑树

###### 栈

stack，又称堆栈，它是运算受限的线性表，其限制是**仅允许在表的一段进行插入和删除操作，不允许在其他位置进行增删改查等操作**

- 采取该结构的集合对元素的存取的特点：**先进后出**
- 栈的入口和出口都是栈的顶端位置

###### 队列

queue，简称队，它同堆栈一样，也是一种运算受限的线性表，其**限制是仅允许在表的一端进行插入，而在表的另一端进行删除**

- 先进先出
- 队列的入口和出口各占一侧

##### 数组

数组：Array，是**有序的元素序列**，数组是在内存中开辟一段**连续**的空间，并在此空间存放元素

- 查询元素块：通过索引查询
- 增删元素慢：指定位置添加元素：需要创建新的数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置

##### 链表

链表：linked list，由一系列结点node（链表中每个元素称为结点）组成，结点可以在运行是动态生成

###### 单向链表特点

每个**结点**包括**两个部分**：一个是存储数据元素的**数据域**，另一个是存储下个结点地址的**指针域**

- 如果指针域没有下一个地址则指针域存 ^ 
- 只能从头向后查

1. 查询慢：需要通过连接的结点，向后依次查询指定元素
2. 增删快：只需更改指针域的地址值

##### 双向链表的特点

每个结点包括**三个部分**：一个是**头指针域**（存放上一个结点的地址），第二个是**数据域**，第三个是**尾指针域**（存放下一个结点的地址）

1. 查询快：相较于单向链表，但占用空间更大
2. 增删快

### Collections工具类

用来操作单列集合，都是静态方法

| 方法名                                                       | 说明                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
| public static void shuffle(List<?> list)                     | 打乱集合顺序（无序性）每次打乱的顺序都不一样 |
| public static<T> void sort(List<?> list)                     | 将集合中元素按照默认规则排序                 |
| public static<T> void sort(List<?> list，Comparator<? super T>) | 将集合中元素按照指定规则排序                 |
| public static boolean addAll(Collection<T> coll , T .... elements) | 批量添加元素到单列集合中                     |

#### Comparator接口（用于排序）

用于自己指定排序规则

使用方式：

1. 通过实现类重写Comparator的抽象方法，在通过Collections工具类中的sort(集合)方法来实现排序（默认方法）
2. 通过Collections工具类中sort(list,Comparator<T> coll(){})来实现排序（自定义方法）

```java
//重写Comparator接口的方法
//格式
Collections.sort(list,new Comparator<T>(){
	public int compare(T 参数1,T 参数2){
  	  return 参数1 - 参数2;//升序
  	  return 参数2 - 参数1;//降序
	}
});
```

#### 增强for循环

**实现Iterator**接口的对象**才可以使用**，用于遍历集合或数组元素

在遍历集合时**是迭代器的简写方式**   

```
//格式
for(元素数据类型 变量名：Collection集合或数组){
	//逻辑
}
```

**注：不能再遍历集合的过程中对集合元素进行增删改操作，数组可以**

### 泛型

在类/方法/接口中预先使用未知数据类型进行代码编写

相当于代码模板，当不确定用户存储的数据类型时，使用E代替

好处：

可以将运行时期的异常提前到编译时期

类型参数化（把一个数据类型当做参数进行使用）

```java
public void add(E e){
	//代码块
}
public E add(int index){
	//代码块
}
```

#### 泛型类

```java
//格式
//如果有多个未知的数据类型可以用 , 隔开 
修饰符 class 类名<代表泛型的变量,变量2>{
    private 泛型变量 name;
    public void setName(泛型变量 name){
		this.name = name;
    }
    public 泛型变量 getName(){
		return name;
    }
}

//确定泛型的时机：创建对象时
类名<> 对象名 = new 类名<>();// 当<>中什么也不给，默认Object类型
```

#### 泛型方法

强制返回值类型和参数类型一样时才使用泛型方法

```java
//格式
修饰符<代表泛型的变量> 返回类型 方法名(参数){}
//例
public <E> void addElement(ArrayList<E> list,E e){
    list.add(e);
}
//确定泛型的时机：调用方法时
```

#### 泛型接口

```java
//格式
修饰符 interface 接口名<代表泛型的变量>{
    泛型变量 方法名();
}
//确定泛型的时机：实现接口时
//如果实现类也不确定泛型的类型时，则实现类也必须是泛型类
//例
public class 实现类名<泛型变量名> implement 接口名<泛型变量> {
    
}
```

#### 泛型通配符

当使用泛型类或者接口时，传递的数据中，**泛型类型不确定**，可以使用通配符**<?>**表示。但是一旦使用泛型的通配符后，**只能使用Objec类**中的**共性方法**，集合中元素**自身方法无法使用**

#### 泛型的上限

```java
//格式
类型名称<? extends类>对象名
//只能接收该类型及其子类
```

#### 泛型的下限

```java
//格式
类型名称<? super类>对象名
//只能接收该类型及其父类
```

# 进阶第8天

### Map集合

元素成对出现，每个元素由键和值两部分组成，通过键获得对应的值，称为双列集合

特点：

1. 不能通过值找键
2. Key唯一

| 方法名                                     | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| public V put(K key,V value)                | 指定的键与指定的值添加到Map集合中                            |
| public V get(Object key)                   | 根据指定的键，在Map集合中获取对应的值                        |
| public V remove(Object key)                | 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值 |
| public Set<K> keySet()                     | 获得Map集合中所有的键，存储到Set集合中                       |
| public Collection<V> values()              | 返回Map集合中的所有的值到Collection集合                      |
| public Set<Map,Entry<K，V>>entrySet()      | 获取到Map集合中所有的键值对对象的集合（Set集合）             |
| public boolean containsKey(Object key)     | 判断该集合中是否有此键                                       |
| public boolean containsValue(Object value) | 判断该集合中是否有此值                                       |

#### HashMap集合

使用频率最高的双列集合，是一个泛型类，需要在创建对象是明确泛型类型的具体类型

**HashMap无参构造默认创建容量为16，（负载因子0.75，当容量添加到75%时，会扩容）**

特点：

1. 底层数据结构是哈希表

2. key值唯一

3. 用做键的对象，应该重写**hashCode()方法和equlas()方法**

4. 键值可以使用null

5. 线程不安去，运行速度快

   使用remove方法删除时，需要判断参数的哈希值以及参数的equals方法，自定义类一定要重写equals和hashCode方法

```jaVA
//Map中没有要添加的键值返回一个null，如果Map中存在要添加的键值则返回以存在的键对应的值并覆盖原来Value的值
public V put(K k,V v);
//返回已删除键对应的值
public V remove(Object k);
//键值对必须都在Map中一一对应才会删除，成功返回true（底层逻辑判断键对应的值是否一样）
public boolean remove(Object k,Object v);
//返回查找键对应的值，找到返回对应的值，未找到返回null
public V get(K k);
```

#### LinkedHashMap集合

在基于HashMap底层哈希表上多维护了一个链表（**保证存入取出的顺序一致**）

特点

1. 底层数据结构是哈希表+链表
2. 有序
3. 无索引
4. key值唯一

#### Map集合遍历方式

###### 方式1：根据键找值（效率低）

1. 创建Map集合对象，指定键和值的类型

2. Map集合对象调用put方法，添加键值对

3. Map集合对象调用**keySet**方法获取所有的键添加到Set集合中

4. 遍历（迭代器/增强for）所有的键对应的Set集合

   4.1获取到当前的键

   4.2Map集合对象调用get方法，传递当前的键，获取对应的值

   4.3打印键和值

###### 方式2：使用entrySet()方法

1. 使用**entrySet方法**添加到**Set集合**
2. 使用**Set的迭代器**或者增强for遍历
3. 使用**getKey**和**getValue**方法获得键和值

###### 方式3：使用forEach()方法

1. 使用**forEach方法**来遍历Map
2. 参数中写new BiConsumer<K,V>(){}
3. 获取到key和value

#### Map集合排序

1. 先将Map集合使用entrySet方法转换成Set集合
2. 将Set集合元素添加到List集合中
3. 使用Collections.sort()方法进行排序
4. 在使用LinkedHashMap存入排序好的元素

```java
//1. 先将Map集合使用entrySet方法转换成Set集合
HashMap<String,Integer> m = new HashMap<>();
Set<Map.Entry<String,Intrger>> ms = m.entrySet();
//2. 将Set集合元素添加到List集合中
ArrayLsit<Map.Entry<String,Intrger>> al = new ArrayList<>();
al.addAll(ms);
//3. 使用Collections.sort()方法进行排序
Collections.sort(al,new Comparator(){});
//4. 在使用LinkedHashMap存入排序好的元素
LinkedHashMap<String,Integer> lhm = new LinkedHashMap<>();
for(Map.Entry<String,Integer> entry : al){
	lhm.put(entry.getKey(),entry.getValue());
}
```

#### Properties集合

双列集合，是Map接口的实现类HashTable的子类，和I/O流结合使用，数据可以持久化，使用量大，**读取配置文件**，一般存储字符串

创建该对象时 不用传入泛型：继承HashTable的时候已经指定了泛型<Object,Object>

```java
//只有一个无参构造
public properties()
```

##### properties文件类型的概述

是一种具有指定格式的文件，这种格式非常适用于配置信息的保存，所以保存配置信息的文件一般都是这种文件

###### 文件格式

新建文件指定后缀为.properties

内容要按照KEY=VALUE的方式进行编写

特点：

1. 底层数据结构是哈希表
2. 键值不允许null
3. 此集合存储的键值对数据类型**固定为String**
4. 和I/O流结合使用，从流中加载数据

```java
//特有成员方法，但Map的成员方法也有

Object setProperty(String key,String value);//保存一个字符串类型的 键和值 到集合中，底层调用HashTable的put方法

String getProperty(String key);//传入字符串类型的KEY获取到对应的字符串类型的值，键值都为字符串类型才可以获取到

Set<String> stringPropertyNames()//获取Properties集合中所有String类型的键组成的Set集合，，键值都为字符串类型才可以获取到
    
    
    
// Properties集合与IO流结合的方法
    
void load(InputStream inStream);//从输入的字节流读取属性列表（键和元素对）

void load(Reader reader);//从输入的字符流读取属性列表（键和元素对）

void store(OutputStream out,String comments);//将此属性列表（键和元素对）写入Properties表中，以适用于使用load（InputStream）方法的格式写入输出字节流

void store(Witer witer,String comments);//将此属性列表（键和元素对）写入此Properties表中，以适用于使用load（Reader）方法的格式写入输出字符流，第二个参数是：注释信息（可以为null）
```



#### 可变参数

可以变的参数，类型确定，个数不确定

由Java**编译时**将参数创建为**一个对应类型的一个数组**

**好处**：不需要调用者完成数据的封装

```java
public static <T> boolean addAll(Collection<T> c,T...elements);
// 注意事项：
// 1.本质就是一个数组
// 2.不穿参数。长度就是0，传几个参数，长度就是几
// 3.一个方法中只能有一个可变参数，如果有多个参数，可变参数只能写在最后一位
// Collections中也提供了添加一些元素
调用格式：
    1. 方法名(参数1，参数2,...)；
    2. 方法名()；
    3. 方法名(null) // 可能空指针异常
```

# 进阶第9天

### 多线程

**线程是程序运行的载体**

可以让多个线程（包含的代码）一起执行

官方：是指**软件**或**硬件上**实现多个线程**并发执行的技术**

#### 并发与并行

##### 并行

在同一时刻，有多个指令在多个CPU上同时执行

##### 并发

在某个时间段，有多个指令在单个CPU上交替执行

#### 进程与线程

##### 进程 Process

1. 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位
2. 动态性：就是一个应用程序从启动到关闭的过程
3. 并发性：基于Windows系统的支持，一个进程可以与其他进程一起执行

##### 线程 Thread

是程序中的一条单一控制流（功能）

**是负责运行进程中的功能**

#### 主线程

Java虚拟机是一个进程（在系统中分配内存空间/加入CPU调度），编写的代码（进程中的一个功能），我们的代码要写运行，必须要有一条线程来执行

我们编写的代码默认是被一条叫做主线程/也叫做MIAN线程的线程执行的

#### 线程依赖于进程（强依赖），进程也变相依赖于线程（弱依赖），进程大线程小

#### 多线程的调度模型

##### 分时调度模型

CPU将时间片平均分配给每一个线程（实际中很少有分时调度）

##### 抢占式调度模型

CPU会自己进行线程的选择（开发者无法控制）可能在执行的过程中CPU会随时选择另外一个线程继续执行（**线程会抢夺CPU的执行权（执行过程中可能会被其他线程抢走））**

#### 多线程的实现方式

##### 继承方式创建线程

1. 自定义子类并继承Thread类
2. 主动重写run方法
3. 使用start方法启动线程

###### 为什么不创建Thread对象并启动对象？

Thread类的run方法已经固定（创建**无参构造时**，底层源码**Runnable target值是null**，**在运行run方式时就是什么也不执行**），不能修改源码，只能够编写子类继承Thread类，重写run方法，创建子类的时候start方法让Java虚拟机运行的就是重写run方法

```java
	public Thread() {
        init(null, null, "Thread-" + nextThreadNum(), 0);
    }

	public void run() {
        if (target != null) {
            target.run();
        }
    }

```



###### 为什么启动线程要调用start而不是直接run？

调用run方法，那么**没有通知**Java虚拟机**运行线程**，run方法就是一个**普通的方法**调用

##### 使用线程任务（Runnable）接口

**可以降低**线程任务（要执行的代码）和线程本身的耦合度

1. 自定义类实现Runnable接口
2. 重写run方法
3. 创建自定义线程任务类对象
4. 创建Thread类对象，将实现Runnable类对象放到Thread有参构造里
5. 使用Thread对象的start方法启动线程

```java
// 获取当前线程对象
public static native Thread currentThread();
```

**底层逻辑**

Thread类中有一个Runnable类型的成员变量target，构造方法**传递**的就是**Runnable接口**的**实现类对象**，当Thread的run方法默认**执行的是实现类对象的run方法**

#### 线程栈

1. 就是**记录**线程**执行情况**的一块空间，记录了线程**执行的历史**
2. **各线程栈是隔离的**
3. **start方法只是通知Java虚拟机开始运行线程，通知完就出栈了**

#### 线程的成员方法

##### 线程命名与获取的方法

1. 设置：
   1. public void setName  ；
   2. 创建并使用有参构造
2. 获取：public String getName  ； 
   - 默认名生成时机：在无参构造时

##### 线程的优先级

是一个数字，优先级高的线程被CPU选择执行的几率更大（相对优先）

###### 优先级范围

Min（1） 到MAX（10）正常创建的线程是NORMAL（5）

```java
// 设置优先级
public void setPriority(int priority)
// 获取优先级
public int getPriority()
```

##### 线程休眠

```java
// 线程休眠的毫秒
public static native void sleep(long millis) throws InterruptedException;
```

#### 线程访问共享资源如何定义

1. 作为线程任务的成员变量
2. 作为某个类的静态成员变量

**线程是随机的由CPU随机选择**

**ThreadLoacl**

实现了一个数据在一个线程中的共享

每个线程都是独立的**栈空间**（每个线程是独立的栈）

**栈空间各线程私有空间**

**堆空间各线程共享**；**堆空间通过栈空间操作，可以多个栈操作同一个堆空间**

ThreadLocal对象，**能够把数据存到当前的线程中，可以从当前线程中的任意位置把存的数据取出来，这样就实现了一个数据在一个线程中的共享**

```java
Threadlocal<String> local = new Threadlocal<>();
local.set("aaa");
local.get();
//ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问当前线程对应的值。
```



#### 线程安全的前提

1. 多线程访问共享资源
2. 多线程访问共享资源并进行修改
3. 多个线程同步执行

#### 线程安全的解决方案

##### 同步代码块

锁多条操作共享数据的语句

**缺点**：获取锁对象和释放锁对象的操作是隐式的

```java
synchronnized(任意对象){
	// 多条语句操作共享数据;
}
```

###### 特点

- ()中的对象称之为**锁对象**；当任意一个**线程执行**同步代码块的时候，判断**锁对象**是否被其他**线程持有**，如果**没有**，则该线程**可以持有锁对象**并且**执行同步代码块**中的内容，如果锁对象被**其他线程持有**了，则**该线程等待**
- 当一个**线程持有锁对象**的时候可以执行同步代码块中的代码，当**代码执行完毕**，会**自动释放锁对象**，执行过程中**出现异常没出来也会自动释放锁**
- 当同步代码块中**进入线程休眠状态**的时候（CPU不会再选择此线程执行），此线程也**不会释放锁对象**

###### 任意对象的要求

必须全局唯一

###### 注意事项

1. 不建议使用String和Integer作为锁对象
2. 建议使用private static fianl Object LOCK = new Object();
3. 效率较低

##### 同步方法

将需要同步的代码抽取出来

```java
// 普通同步方法  属于this
权限修饰符 synchronized 返回值 方法名(){}
// 静态同步方法  属于当前类
权限修饰符 synchronized static 返回值 方法名(){}
```

###### 同步代码块和同步方法的锁对象的区别

1. 同步代码块的锁需要开发者显式声明（必须在synchronized()中编写锁对象）
2. 同步方法不需要开发者显示声明，已被被Java默认了

###### 注意事项

Java中的线程安全的类一般都是通过同步方法来保证安全的

##### Lock锁接口

JDK1.5推出，更直观的让开发者看到锁对象和释放对象的操作（更面向对象实现）

使用ReentrantLock实现类

```java
private static final Lock LOCK = new RenntrantLock();
LOCK.lock();
LOCK.unlock();
// 获得锁
void lock();
// 释放锁
void unlock();
```

# 进阶第10天

#### 线程异常与解决方案

1. 同步代码块异常
   - 一个线程出异常**不会影响其他线程，也不会影响锁的释放**
2. 同步方法中异常
   - 一个线程出异常**不会影响其他线程，也不会影响锁的释放**
3. Lock锁异常
   - 一个线程出异常**不会影响其他线程，但会影响锁的释放**
   - **解决方案**：在线程执行过程中，有可能出现异常，导致unlock()方法并不会执行，不执行就不会释放对象，所以要**使用try{}catch{}finally{}**的方式将**释放锁的代码**写在**finally代码块**中

#### 线程的六种状态	

1. NEW(新建状态)：没start之前

2. RUNNABLE(运行状态)：调用start之后

3. WAITING(无限等待状态)：调用wait之后，不使用notify或者notifyAll会一直等待

4. TIMED_WAITING(记时等待状态)：调用Thread.sleep之后

5. BLOCKED(锁阻塞状态)：CPU不会选择处于这个状态的线程

6. TERMINATED(终结状态)：run方法执行完毕，自动进入终结状态（等待被垃圾回收器回收）

   **3.4.5只能和运行状态互相转换**	去求1

getState获取线程状态

#### 线程死锁

多个线程都持有对方线程所需要的锁，有需要对方线程释放锁造成等阻塞情况

##### 处理死锁

1. 如果多把锁，尝试变成1把
2. 如果多个线程加锁的顺序不一致，尝试将加锁顺序修改一致
3. 线程任务执行的代码可能会调用其他类的成员方法，在其他的类中也有锁的存在
4. 使用监控工具分析锁的使用情况

#### 线程通信

##### 等待和唤醒的方法

##### 使用前提：

1. 这个三个方法需要被锁对象调用（同步代码块/同步方法）[等待区]
2. 三个方法必须在同步代码块/同步方法中使用

```java
// 当前线程等待
void wait();
// 唤醒正在等待对象监视器的单个线程
void notify();
// 唤醒正在等待对象监视器的所以线程
void notifyAll();
```

#### 线程池

是一个容器，提供线程的存储，线程的使用，线程的管理

##### 优点

为了提高线程的复用性

##### 获取方式

1. 使用工具类获取

   ```java
   Executors.newFixeThreadPool(10);//创建容量为10的线程池
   Executors.newFixeThreadPool();//无上限
   ```

2. 自定义获取：ThreadPoolExecutor（是实现了ExecutorServiec线程池规范接口的实现类）

   - 它的构造方法参数详解
     1. int corePoolSize **核心线程数** 线程之后执行的线程任务是CPU密集（当前机器CPU核心数+1），I/O密集（当前CPU核心数x2）
     2. int maxmumPoolSize **最大线程数** 核心线程 + 临时线程 = 最大线程
     3. long keepAliveTime **临时线程存活时间** 数值单位1000 （**空闲线程等待新任务的最长时间**）
     4. TimeUnit unit **临时线程存活时间单位** 秒/分/小时，使用TimeUnit.SECOND（**空闲线程等待新任务的最长时间单位**）
     5. BlockingQueue<Runnable> workQueue **额外任务的阻塞队列 ** 当前所用的线程都在忙碌，提交的线程任务存储的集合
        - 使用ArrayBlockQueue<> **有界阻塞队列** 在创建队列的时候需要传递队中的最大容量 =》new rrayBlockQueue<>(10)
        - LinkedBlockingQueue<> **无界阻塞队列** 在创建队列的时候不需要传递队中的最大容量，无上限
     6. ThreadFactory threadFactory **线程工厂** 提供线程池中的线程，固定写法Exectors.defaultThreadFactory() [默认返回一个可用的线程工厂]
     7. RejectedExecutionHandler handler **拒绝提交策略**
        1. ThreadPoolExecutor.AboryPolicy：如果线程池所有线程在忙，阻塞队列也满了 =》 **丢弃任务，抛出（运行期）异常**
        2. ThreadPoolExecutor.DiscardPolicy : 如果线程池所有线程在忙,阻塞队列也满了 => **丢弃任务,不抛出异常.**
        3. ThreadPoolExecutor.DiscardOldestPolicy : 如果线程池所有线程在忙,阻塞队列也满了 => **让阻塞队列中等待时间最长的线程任务与新提交的线程任务交换.**
        4. ThreadPoolExecutor.CallerRunsPolicy : 如果线程池所有线程在忙,阻塞队列也满了 => **跳过线程池找空闲线程执行.**

   

##### 提交方式

```java
// 提交一个线程任务交给线程池
public Future submit(Runnable target);
// 关闭线程池
public void shutdown();
// 马上关闭线程次，有未执行的任务保存到集合中并返回
public void shutdownNow();
```

##### 异步Callable接口

就是Runnable接口的改进版，可以返回值

```java
//1.创建Callable接口的实现类对象
//2.使用FutureTask对象来包装Callable对象来接收Callable的返回值
//3.使用Thread线程start
//4.获取返回值使用FutureTask对象的get方法
		CallableDemo demo = new CallableDemo();
        FutureTask<Integer> futureTask = new FutureTask<>(demo);
        new Thread(futureTask,"aa").start();
        System.out.println(futureTask.get());
```

# 进阶第11天

#### File类

一个File对象表示系统中的一个文件或文件夹

```java
//构造方法
//1.通过传入的路径指定的文件或者文件夹创建File对象
public File(String pathname);

    
File f = new File("H:\\hello\\HelloWord.txt");//文件
File f = new File("H:\\hello");//文件夹

//2.通过传入的父路径和子路径指定的文件或者文件夹创建File对象，用于封装一个文件夹下的多个文件
String parent = "H:\\hello";
File f = new File(parent,"HelloWord.txt");
//3.通过传入的父File对象和子路径指定的文件或者文件夹创建File对象
File parent = new File("H:\\hello");
File f = new File(parent,"HelloWord.txt");
//相对路径，封装简单
File f = new File("Day11_FileAndIO\\HelloWord.txt");//相对于模块
File f = new File("HelloWord.txt");//相对于项目
```

##### 相对路径

是指相对于当前项目或模块的路径

##### 绝对路径

是指从盘符开始的路径，找到对应的文件

##### File的成员方法

###### 获取方法

```java
public String getAbsolutePath();//获取File对象表示内容的绝对路径
public String getPath();//获取File对象封装时路径
public File geParentFile();//获取File对象父路径字符串并封装为File对象
public String geParent();//获取File对象父路径字符串
public String getName();//获取File对象表示内容的名称
public Long length();//获取File对象表示文件的字节数（大小）
```

###### 判断方法

```java
public boolean exitts();//判断File对象是否存在
public boolean isFile();//判断File对象是否是一个文件
public boolean isDirectory();//判断File对象是否是一个文件夹
```

###### 创建方法

```java
public boolean createNewFile();//将调用的对象表示的路径表示的内容创建为一个文件
public boolean mkdirs();//可以创建多级文件夹
```

###### 删除方法

删除的内容不会进入回收站，物理删除

```java
public boolean delete();//删除此抽象路径表示的文件或者文件夹，如果删除的是文件夹，那文件夹必须为空
```

###### 遍历方法

```java
pblic File[] listFiles();//返回路径文件夹中的文件和目录的File对象数组
```

#### 递归

###### 注意事项

必须给出口（什么情况下不在进行递归）

#### IO流

进行文件数据的写入和写出

读取（Input）输入流：从硬盘到内存

输出（Output）输出流：从内存到硬盘

#### 字节流（Stream）

- 字节流：操作一切文件
- 字符流：操作文本文件
- 所有输出流的抽象父类：OutputStream

##### 字节输出流FileOutputStream

```java
FileOutputStream(File file);//清空原数据
FileOutputStream(String path);
FileOutputStream(File file,boolean append);//不清空原数据，追加写入
FileOutputStream(String path,boolean append);

// 数据写入
void write(int b);//一次写一个字节数据
void write(byte[] b);//一次写一个字节数组
void write(byte[] b,int off,int len);//一次写一个字节数组的部分数据

//String类型的字符串写入
String str = "哈哈哈哈";
byte[] bt = str.getBytes();
FileOutputStream fos = new FileOutputStream("");
fos.write(bt);
```

###### 注意事项

1. 如果文件不存在，则自动创建
2. 如果文件存在，则自动清空文件的所有内容
3. 如果字节输出流绑定的File对象是一个文件夹，则报FileNotFoundException（拒绝访问）
4. 操作完文件，一定要**使用close方法释放资源**
5. 流和迭代器很像（**都是一次性的**），read方法只要读到文件**末尾（-1）**就不会变了，**需要重新创建**

##### 字节输入流FileInputStream

```java
FileInputStream(File file);
FileInputStream(String path);

// 数据读取
int read();//一次读一个字节数据，将读取的数据返回，如果返回-1则读取完毕
int read(byte[] b);//一次读一个字节数组数据，返回读取到的有效个数，如果返回-1则读取完毕

//1.循环读取文件内容
int i;
while((i= fis.read()) != -1){
    sout((char)i);
} 
//2.循环读取文件内容
byte[] bytes = new byte[1024];
int len;
while((len= fis.read(bytes)) != -1){
    String str = new String(bytes);
    String str = new String(bytes,0,len);
    sout(s);
    sout(s.length);
} 
```

###### 注意事项

1. 如果绑定的文件不存在，则会报错（FileNotFoundException找不到文件）
2. 如果绑定的是文件夹，则会报错（FileNotFoundException拒绝访问）

##### 缓冲字节输出流BufferedOutputStream

基于底层字节流的高效实现

比字节流的速度要快的多：有个缓冲区，**写数据的时候先把数据写入到缓冲区，等缓冲区的数据足够多时再一次写入到硬盘中**

```java
BufferedOutputStream(OutputStream os);

// 数据写入 同FileOutputStream
```

##### 缓冲字节输入流BufferedInputStream

同缓冲字节输出流 

# 进阶第12天

#### 编码与解码

计算机中存储的信息都是二进制数表示的

按照某种规则，将字符存储到计算机中，称为编码

按照同样的规则，将存储在计算机中的二进制数解析显示出来，称为解码

编码和解码的规则需要一致，否者会乱码

##### 字符集分类

1. ASCII字符接（美国标准信息交换代码）：包含了字母/数字/常用符号，所有字符编码后均为一个字节
2. GB系列中的GBK字符集（国标字符集），里面包含了21003个**汉字和其码点的对应关系**，兼容ASCII码表，
   1. 基于**GBK编码**后英文编码后是一个字节，
   2. **汉字是两个字节**
3. Unicode字符集：包含了绝大数国家的文字（emoji）都有对应码点；先通过UTF-8编码方式将码点转为数字，再讲数字转为二进制；（UTF-16/32定长编码，不管什么字符编码后都是四个字节）
   1. 基于UTF-8编码后英文是一个字节
   2. 法语和其他国家是两个字节
   3. 中文是三个字节
   4. 稀奇古怪的文字是四个字节
4. Big5字符集

##### 编码

基于String字符串使用

```java
//1.根据平台默认的编码方式对内容进行编码，将编码后的内容组成一个字节数返回
String s = "你好！";
Byte[] bytes = s.getBytes();
public byte[] getBytes();
//2.根据指定字符集对内容进行编码
Byte[] bytes = s.getBytes("GBK");
public byte[] getBytes(String charsetName);
```

##### 解码

基于String字符串使用（构造器）

```java
//1.根据平台默认方式对参数进行解码
Byte[] bytes = {-28,-67,-96,-27,-91,-67};
public String(Byte[] bytes);
String str = new String(bytes);
//1.根据指定方式对参数进行解码
public String(Byte[] bytes,String charestName);
String str = new String(bytes,"GBK");
```

读取过程中有可能只读到字符的三分之一，并进行转码，就会造成乱码，但拷贝不会

#### 字符流（Writer，Reader）

##### 原生字符输出流OutputStreamWriter

Writer所有字符输出流的抽象父类

***是字符到字节的桥梁***，可以直接将字符内容直接写出到文件中

**可以按照指定的字符集对写出的字符进行编码**

```java
//构造方法
public OutputStreamWriter(OutputStream);//按照平台的字符集创建字符输出流对象
public OutputStreamWriter(OutputStream,String charsetName);//按照指定的字符集从创建字符输出流对象
```

```java
//成员方法
public void write(int c);//写出一个字符数据，可以将一个完整字符写出（中文也可以）
public void write(char[] chars);//写出一个字符数组数据
public void write(char[] chars,int off,int len);//写出一个字符数组数据（从off索引开始写，写len个数据）
public void write(String str);//写出一个字符串数据
public void write(String str,int off,int len);//写出一个字符串数据（从off索引开始写，写len个数据）
```

###### 底层原理

从字符到字节的桥梁，创建OutoutStreamWriter对象后，先去码表里找对应的字符码点，然后进行编码，关闭或刷新流资源后，在传给FileOutputStream对象进行写数据

###### 注意事项

- 字符流的write方法调用后，不会直接写入到文件中；
  - 使用close方法关闭流资源后写入文件（**推荐**）
  - 使用flush方法刷新流对象写入文件

##### 原生字符输入流InputStreamReader

Reader所有字符输入流的抽象父类

***字节到字符的桥梁***，可以直接将字节内容直接读入到内存中

**可以按照指定的字符集对读入的字符进行转码**

```java
//构造方法
public InputStreamReader(InputStream is);//按照平台默认的字符集创建原生字符输入流
public InputStreamReader(InputStream is,String CharsetName);//按照指定的字符集创建原生字符输入流
```

```java
//成员方法
public int read();//一次读取一个字符数据，将读到的内容作为返回值，如果返回-1则读取到文件末尾
public int read(char[] chars);//一次读取一个字符数组，将读到的有效字符数作为返回值，如果返回-1则读取到文件末尾
```

###### 底层原理

从字节到字符的桥梁，创建InputStreamWriter对象后，在文件开始读取字节，每读一次，字符会判断是不是一个完整字符，是则返回，不是则继续读取。

*什么是转换流：**当一个绑定了目标的字节输入流的时候，想按照字符的方式来读取数据，将字节输入流作为字符输入流的构造参数***

###### 注意事项

- 字符流的write方法调用后，不会直接写入到文件中；
  - 使用close方法关闭流资源后写入文件（**推荐**）
  - 使用flush方法刷新流对象写入文件

##### 便捷字符输出流FileWriter

默认只需要绑定文件就可以操作文件，是OutputStreamWriter的子类

```java
//构造方法
public FileWriter(File file);//创建便捷字符输出流绑定File文件对象
public FileWriter(String path);//创建便捷字符输出流并绑定路径指向的文件
```

```java
//成员方法同父类的方法
```

###### 使用前提

- 如果只是单纯想要通过**字符的方式去读取数据**，**不需要指定字符集**，也不要求对某一个字节流进行转换，**就用**便捷字符输入流
- 想要按照**指定**的**字符集想文件中写出数据**/已经有一个绑定好文件的字节流，就用**原生字符输出流**

##### 便捷字符输入流FileReader

默认只需要绑定文件就可以操作文件，是InputStreamReader的子类

```java
//构造方法
public FileReader(File file);//创建便捷字符输入流绑定File文件对象
public FileReader(String path);//创建便捷字符输入流并绑定路径指向的文件
```

```java
//成员方法同父类的方法
```

###### 使用前提

- 如果只是单纯想要通过**字符的方式去读取数据**，**不需要指定字符集**，也不要求对某一个字节流进行转换，**就用**便捷字符输入流
- 想要按照**指定**的**字符集想文件中写出数据**/已经有一个绑定好文件的字节流，就用**原生字符输出流**

##### 缓冲字符输出流BufferedWriter

对单个字符，字符数组，字符串**高效写入**，本身不具备真正的写数据到文件的能力，它需要**一个字节流**帮它完成数据的写入，还需要**一个字符流**帮他完成字符到字节的转换，**只提供缓冲区**

```java
//构造方法
public BufferedWriter(Writer w);
```

```java
//成员方法
public void write(int c);//写出一个字符数据，可以将一个完整字符写出（中文也可以）
public void write(char[] chars);//写出一个字符数组数据
public void write(char[] chars,int off,int len);//写出一个字符数组数据（从off索引开始写，写len个数据）
public void write(String str);//写出一个字符串数据
public void write(String str,int off,int len);//写出一个字符串数据（从off索引开始写，写len个数据）
public void newLine();//根据操作系统来换行
```

###### 注意事项

需要释放资源或者刷新缓冲区，才可以写入数据

##### 缓冲字符输入流BufferedReader

对单个字符，字符数组，字符串**高效写入**，本身不具备真正的写数据到文件的能力，它需要**一个字节流**帮它完成数据的读取，还需要**一个字符流**帮他完成字节到字符的转换，**只提供缓冲区**

```java
//构造方法
public BufferedReader(Reader r);
```

```java
//成员方法
public int read();//一次读取一个字符数据，将读到的内容作为返回值，如果返回-1则读取到文件末尾
public int read(char[] chars);//一次读取一个字符数组，将读到的有效字符数作为返回值，如果返回-1则读取到文件末尾
public String readLine();//一次读取一行数据（读取到换行，返回换行前面的值不包括换行符）返回值null时表示读取到末尾
```

#### 序列化流（ObjectOutputStream）

把一个对象持久化保存

将内存中的对象序列化成字节文件，（序列化本身不具备文件的数据写出，需要一个字节输出流帮他写出数据），它的功能将对象序列化为字节文件

```java
//构造方法
public ObjectOutputStream(OutputStream os);//通过传入一个字符输出流构建一个序列化流
```

```java
//成员方法
public void writeObject(Object obj);//将参数对象序列化到文件中
```

###### 注意事项

- 想要一个对象被序列化需要该类具备被序列化的能力，**就是实现Serializable接口**
- 可以序列化多个对象到同一个文件中（不推荐存多个），推荐使用将对象放到集合中在序列化集合对象

###### 序列化版本号是什么

是系统根据类的组成部分计算出来的一个long类型的数字

当修改类的组成部分在进行反序列化可能出现版本号不一致的问题

**解决办法：**只要实现类序列化接口，就要给这个类一个序列化版本号

#### 反序列化流（ObjectInputStream）

从持久化文件中读取一个对象出来

可以从文件中读取字节序列变成一个内存对象，（反序列化流本身不具备实际读取的操作，需要一个字节输入流帮它读取数据），它的功能是将字节序列化转换为内存对象

```java
//构造方法
public ObjectInputStream(InputStream is);//通过传入一个字节输入流构建一个反序列化流
```

```java
//成员方法
public Object readObject();//从文件中反序列化一个对象内存中
```

###### 注意事项

- 反序列化读到文件末尾时，会抛出异常EOFException

#### 瞬时关键字（transient）

被它修饰的变量在序列化时不会将内容（类属性的值，属性反序列化回来该值为null）序列化到文件中

#### 第三方Jar包

- commons-io包



# 进阶第13天

#### Lambda表达式

函数式编程思想

##### Lambda标准格式

- 方法形式参数为空，说明调用方法时不用传递参数
- 方法返回值类型为void，说明方法执行没有结果返回
- 方法体中的内容，是我们具体要做的事情

组成Lamdba的三要素：形式参数，箭头，代码块

```java
//格式：(形式参数) -> {代码块}
//形式参数：如果有多个参数，参数直接用逗号隔开；没有参数则留空
//->:固定写法，代表指向动作，将形式参数传递到{}中
//代码块：是我们具体要做的事情，业务实现逻辑，可以使用（）中的形式参数
```

###### 省略规则：

- 参数类型可以省略，有多个参数不能只省略一个（全部省略或者全部不省略）
- 如果参数有**且仅有一个**，那么小括号可以省略
- 如果代码块的语句只有一条，可以省略大括号和分号，甚至是return

###### 使用前提

当一个方法的参数或者返回值是函数式接口的时候，使用Lambda作为方法的逻辑进行参数传递

##### Lambda表达式和匿名内部类的区别

**思想不同**

- 匿名内部类是为了创建对象传递面向对象思想
- Lambda表达式是作为方法逻辑传递，函数式编程思想

**所属类型不同**

- 匿名内部类：可以是接口，也可以是抽象类，也可以是具体类
- Lambda：只能是接口

**使用限制不同**

- 如果接口中只有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类
- 如果接口中有多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式

**实现原理不同**

- 匿名内部类：编译之后，产生一个单独的class字节码文件
- Lambda：编译之后，没有一个单独的class字节码文件，对应的字节码会在运行的时候动态生成

#### 函数式接口

在Java中指：有且只有一个抽象方法的接口

具体体现就是Lambda

好处：灵活性

##### FunctionlInterface注解

只是为了绑定函数式接口定义，添加则必须只要一个抽象方法

否则报错，不添加也可以实现函数式接口，

该注解用来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则报错

不使用该注解，只要满足函数式接口定义，这仍然是一个函数式接口

##### Supplier接口（供给型接口）

java.util.function.Supperlier<T>接口，它意味着“供给”，对应的Lambda表达式需要对外提供一个符合泛型类的对象数据

```java
T get();//用于获取一个泛型参数指定类型的对象数据
```

##### Consumer接口（消费型接口）

java.util.function.Consumer<T>接口则正好相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型参数决定

```java
void accepct(T t);//消费（处理）一个指定泛型的类型
```

##### Function接口（转换型接口）

java.util.function.Function<T，R>接口用来根据一个类型的数据得到另一个类型的数据前者称为前置条件，后者称为后置条件，有进有出

```java
R apply(T t);//根据类型T的参数获取类型R的结果

//Java实例：单列集合和双列集合的foreach方法
```

##### Predicate接口（谓词型接口，判断）

对某种类型的数据进行判断，从而得到一个boolean值，这时使用java.util.function.Predicate<T>接口

```java
boolean test(T t);//通过对传入的参数进行判断并返回对应的布尔值

//Java实例：单列集合的removeIf方法就是使用的这个接口
```

#### Stream流

Jdk8中添加，以一种声明的方式处理数据

元素流在管道中经过**中间操作**的处理，最后由**最终操作**得到前面处理的结果

涉及到集合或者数组的操作，先考虑Stream流进行操作

##### Stream流的三类方法

- 获取Stream流

  ​	创建一条流水线，并把数据放到流水线上准备操作

  ```java
  //Stream流的获取方法
  //单利集合
  	使用Collection接口中的默认方法stream()生成流
  	default Stream<E> stream();
  //双列集合
  	间接生成流
  	先通过ketSet或者entrySet获取一个Set集合，在获取Stream流
  //数组
  	Arrays中的静态方法stream生成流
          保存引用类型的数组（返回的流：对象流）
          保存基本类型的数组（返回的流：基本流）
  //同种数据类型的多个数据
  	使用Stream.of(T...values)生产流
  ```

- 中间方法

  ​	流水线上的操作，一次操作完成之后，还可以继续进行其他操作

  ```java
  //Stream流的中间方法
  Stream<T> limit(long maxSize);//截取指定参数个数的数据
  
  Stream<T> skip(long n);//跳过指定参数个数的数据
  
  static <T> Stream<T> concat(Stream a, Stream b);//合并a和b两个流为一个流  使用Stream.concat调用
  
  Stream<T> distinct();//去除流中的重复元素。依赖于hashCode和equals方法
  
  Stream<T> sorted();//根据指定规则排列流中的元素
  
  Stream<T> filter(Predicate<T> predicate);//根据指定的判断逻辑对流中的元素进行过滤（true：保留；false：过滤）
  
  Stream<T> map(Function<T,R> function);//将流中T类型元素按照指定逻辑转换为R类型元素后，返回R类型的流
  ```

- 终结方法

  ​	一个Stream流只能有一个终结方法

  ​	是流水线的最后一个操作

  ```java
  //Stream流的终结方法
  void forEach(Consumer action);//对此流 的每个元素执行操作
  
  long count();//返回此流中的元素数
  ```

- 收集方法

  ​	使用Stream流操作完毕之后使用

  ```java
  //Stream流的收集方法
  R collect(Collector collector)
  
  //工具类Collectors提供了具体的收集方法
  public static <T> Collector toList();//把元素收集到List集合中
  
  public static <T> Collector toSet();//把元素收集到Set集合中，不要排序，不会按排序添加到Set集合中
  
  public static  Collector toMap(Function keyMapper,Function valueMapper);//把元素收集到Map集合中
  
  ```
  
  

# 进阶第14天

#### 软件结构

- C/S：全称为Client/Server结构，指客户端和服务器结构
  - 数据传输在软件内发生，可以保证数据的安全
  - 资源预习下载到本地，加载速度快
  - 但更新是强制的
- B/S：全称为Browser/Server结构，指浏览器和服务器结构
  - 使用者不需要单独下载资源
  - 更新只需要服务器更新，浏览器直接进行访问
  - 数据传输不安全，可能会DNS劫持
  - 服务器压力大

#### 网络编程概述

在网络通信协议下，不同计算机上运行的程序，可以进行数据传输

##### 网络编程的三要素

- IP地址：设备在网络中的地址，是唯一标识
  - Ipv4：32bit（4字节），点分十进制，分4组
  - Ipv6：128bit（16字节），冒分十六进制，分8组
  - 常用命令：ipconfig查看本机ip地址；ping IP地址 检查网络是否连通
- 端口：应用程序在设备中的唯一标识
  - 取值范围：0-65535
  - 0-1023直接的用于知名网络服务或应用
  - 1024以上我们自己使用
  - **一个端口只能用在与一个应用程序上**
  - **但一个应用程序可以使用多个端口**
- 协议：数据在网络中传输的规则，常见的协议有UDP和TCP协议

##### TCP：传输控制协议（Transmission Control Protocol）

面向连接的通信协议

速度慢，没有大小限制，数据安全

##### 通信原理

它在通信的两端各建立一个Socket对象

通信之前要保证连接已经建立

通过Socket产生IO流来进行网络通信

##### TCP发送数据的步骤

1. 创建客户端Socket对象与指定服务端连接 **Socker(String host,int port)**
2. 获取输出流，写数据 OutputStream **getOutputStream()**

   - Socket对象获取的输出流本质上是一个SocketOutputStream（字节输出流），	SocketOutputStream默认是绑定通道
   - ```java
     shutdownOInput();
     shutdownOutput();//终止输出流，让接受端不要（阻塞读取）等待了，完成接收数据，继续向下执行。
     //如果客户端通道的数据发送完成时，客户端剩下的代码是服务端向客户端发送接收成功数据时（仍是需要管道读取和写入数据）而不是释放资源，需要使用shutdownOutput()或者shutdownInput()，来提示socket完成写出或读入
     
     //释放socket.close()时，os.close();也会释放
     ```

3. 释放资源**close()**

##### TCP接收数据的步骤

1. 创建服务端的Socket对象 **ServerSocket(int port)**
2. 监听客户端连接，返回一个Socket对象 **Socket accpet()** 阻塞方法
3. 获取输入流，读数据，并把数据显示在控制台  InputStream **getInputStream()**
   - Socket对象获取的输入流本质上是一个SocketInputStream（字节输入流），	**SocketInputStream默认是绑定通道**，是**阻塞读取**

4. 释放资源 **close()**

##### 三次握手

1. 客户端**向服务器**发出**连接请求**等待**服务器确认**
2. 服务器向客户端**返回一个响应**告诉客户端**收到了请求**
3. 客户端向服务器**再次发出**确认信息**建立连接**

##### 四次挥手

1. **客户端**向服务器**发出取消连接请求**
2. **服务器**向客户端**返回一个响应**表示**收到客户端取消请求**
3. **服务器**向客户端**发出确认取消信息**
4. **客户端**再次**发送确认**消息**连接取消**

**2到3：为了处理客户端最后数据，保证数据安全**

# 进阶第15天

#### 枚举

就是有限且固定的类，在Java里称为枚举类

Jdk1.5添加的引用数据类型，和类，接口一个级别，关键字enum

本质就是一个类的多个（固定的且内容不可改变的）对象

```java
public enum 类名{
	枚举项1,枚举项2,枚举项3...N;//全驼峰蛇形命名法
}
```

##### 特点

1. 所有枚举类都是Enum的子类
2. 我们可以通过**枚举类名.枚举项名称**去访问指定的枚举项
3. 每一个枚举项就是该枚举的一个对象
4. 枚举也是一个类，也可以定义成员变量
5. 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其它的东西，这个分号不可省略
6. 枚举类可以有构造器，但必须是private修饰的，它默认也是private
7. 枚举类也可以有抽象方法，但是枚举项必须重写该方法

##### 本质

编译之后将每一个枚举项都声明为了本类的公共静态不可变的成员变量

##### 常用方法

```java
String name();//获取枚举项的名称
int ordinal();//返回枚举项在枚举类中的索引值
int compareTo(E o);//比较两个枚举项，返回的是索引值的差值
String toString();//返回枚举常量的名称
static <T> T valueOf(Class<T> type,String name);//获取指定枚举类的指定名称的枚举值
values();//获得所有的枚举项
```

#### XML

可扩展标记语言

**XML与HTML的主要差异？**

1. xml标签都是自定义的，HTML是预定义
2. XML的语法严格，HTML松散
3. XML是存储数据的，HTML是展示数据

**XML文件是有很多标签组成的，而标签名是可以自定义的**

##### 语法规则

1. 文件后缀为xml

2. 文档声明**必须**是第一行第一列

   - <?xml version="1.0" encoding="UTF-8" standalone="yes”?>

     version:该属性是必须存在的

     encoding:该属性不是必须的

     ​    				打开当前xml件的时候应该是使用什么字符编码表(一般取值都是UTF-8)

      standalone:该属性不是必须的,描述XML文件是否依赖其他的xml文件,取值为yes/no.

3. 必须存在一个根标签，有且只能有一个

4. 可以定义注释信息 <!-- -->

5. 可以使用特殊字符

   - &lt ;   <  小于
   - &gt ;  >  大于
   - &amp ;  &  and
   - &apos ；  ’   单引号
   - &quot；  "   双引号

6. 可以存CDATA区（可以批量使用有歧义的字符）

   - <![CDATA[ 内容 ]]>

##### **标签规范**

1. 标签必须有**一对尖括号**的合法标识符组成
2. 标签的方式可以是**开始结束**方式也可以是**自闭和**方式
3. 标签中可以编写文本内容进行声明，也可以嵌套其他的标签用于声明数据的关系；如果包含其他标签，分为简单标签（简单元素）和复杂标签
4. 标签中可以声明属性（0-N），声明的时候属性**名**不需要加"" 或''，属性**值**必须加""或 ''
5. 标签与标签的**不能你中有我我中有你**（必须完整包裹）

##### XML解析

1. DOM：要求解析器把整个XML文档装载到内存，并解析成一个Document对象
   - 优点：元素与元素之间保留结构关系，故可以进行增删改查操作
   - 缺点：XML文档过大，可能出现内存溢出
2. SAX：是一种速度更快，更有效的方法，它逐行扫描文档，一边扫描一边解析
   - 优点：处理速度快，可以处理大文件
   - 缺点：只能读，逐行后将释放资源
3. PULL：Android内置的XML解析方式，类似SAX

```java
//Dom4j解析步骤
1. public SaxReader();//无参构造
2. saxReader.read(File file);//获取Document对象
3. Document对象.getRootElement();//获取到Xml文档中的根标签的Element对象
4. rootElement对象.elements("标签名");//获取到标签名的组成的List集合
5. list集合对象.foreach();//遍历标签名的子标签
6. 遍历出来的对象.element("子标签名");//获取子标签的element对象
7. 子标签对象.getText();//获取子标签的值
（6 + 7 合并为一步）遍历出来的对象.elementText("子标签名");
8. element对象.attributeValue("属性名");//获取调用该标签的属性值

```

###### 解析三要素

1. XML文档可以看做Document对象
2. XML文档中的任意一组标签可以看做Element对象（粒度：可大可小）
3. XML文档中的任意一个属性可以看Attribute对象（只要是属性）

##### XML约束

用来限定xml文件中可使用的标签以及属性

###### 分类

约束主要分为DTD和Schema两种约束技术

- DTD约束

  1. 创建一个文件，这个文件的后缀为.dtd

  2. 看xml文件中使用了哪些元素

     1. <!ELEMENT>可以定义元素

  3. 判断元素时简单元素还是复杂元素

     1. 简单元素：没有子元素
     2. 复杂元素：有子元素的元素

  4. **引入DTD约束**

     1. 本地引入：<!DOCTYPE 根元素名称 SYSTEM 'DTD文件的路径'>
     2. 在XML文件内部引入：<!DOCTYPE 根元素名称 [dtd文件内容]>
     3. 网络引入：<!DOCTYPE 根元素名称 PUBLIC "DTD文件名称" "DTD文档的URL">

  5. DTD约束语法规则

     1. 定义一个元素的格式为：<!ELEMENT 元素名 元素类型>

        1. 简单元素：

           1. EMPTY：表示标签体为空
           2. ANY：表示标签体可以为空也可以不为空
           3. PCDATA：表示该元素的内容部分为字符串

        2. 复杂元素：直接写子元素名称

            <!ELEMENT persons (person+) >
            <!ELEMENT person (name , age)>
            <!ELEMENT name (#PCDATA)>
            <!ELEMENT age (#PCDATA) >

           - 多个子元素可以使用 “，” 或者 “ | ” 隔开；
             - ，表示定义子元素的顺序
             - | 表示子元素只能出现任意一个

     2. 定义一个属性的格式为：<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束>    <!ATTLIST person id CDATA #FIXED "p1" >

        - 属性的类型：CDATA类型：普通的字符串
        - 属性的约束：
          - #REQUIRED：必须的
          - #IMPLIED：属性不是必须的
          - #FIXED value：属性值是固定的

  6. Schema约束：支持的数据类型更复杂；支持**名称空间**

# 进阶16天

#### Junit单元测试

是Java编程语言的单元测试工具

- 是一个开放源代码的测试工具
- 提供注解类识别测试方法
- 可以提高代码质量，编写代码更快
- 在一个条中显示进度。如果运行良好则是绿色；运行失败则是红色

###### 使用流程

- 导入Jar包到工程中
- 编写测试方法该方法必须是**公共的无参数无返回值的静态方法**
- **在测试方法上使用@Test**注解标注该方法是一个测试方法
- 选中测试方法右键通过junit运行该方法

###### 注意事项

- 由于测试方法是单独运行，所以没有调用者传递参数，也不需要返回内容给调用者
- 测试方法并不是main方法，就是一个普通的成员方法，也不需要加static

###### 常用注解

| 注解    | 含义                                 |
| ------- | ------------------------------------ |
| @Test   | 表示测试该方法                       |
| @Before | 在测试的方法前运行（用于初始化数据） |
| @After  | 在测试的方法后运行                   |

##### 黑盒测试

不需要写代码，给输入值看程序是否能输出期望的值

##### 白盒测试

需要写代码。关注程序具体的执行流程

#### 类加载器

**负责将.class文件（存储的物理文件）加载到内存中**

Java文件，编译成=》class文件也叫字节码文件，类加载器 =》加载到虚拟机中

class是一个物理文件存在于硬盘中，虚拟机是一个进程存在于内存中

##### 类加载的时机

**用到就加载，不用不加载**

1. 创建类的实例（对象）
2. 调用类的类方法
3. 访问类或者接口的类变量，或者为该类变量赋值
4. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
5. 初始化某个类的子类（会加载父类到虚拟机中）
6. 直接使用java.exe命令类运行某个主类

##### 类加载的过程

加载 =》验证 =》准备 =》解析 =》初始化

1. **加载：**
   1. 通过一个类的全限定名来获取定义此类的二进制字节流（**通过（全限定名）包名 + 类名，获取这个类，准备用流进行传输**）
   2. 将这个字节流所代表的静态存储结构转化为运行时数据结构（**在这个类加载到内存中**）
   3. 在内存中生成一个代表这个类的java.lang.Class对象，任何类被使用时，系统都会为之建立一个java.lang.Class对象（**加载完毕创建一个class对象**）（保存了类的各项信息，构造，成员，方法）
2. **验证：**
   1. 链接阶段的第一步，这个阶段为了确保class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟接自身安全（**文件中的信息是否符合虚拟机规范，有没有安全隐患**）
3. **准备：**
   1. 负责为类的类变量（被static修饰的变量）分配内存空间，并设置**默认值**，不会进行赋值（不管有没有赋值只会赋默认值，不会进行自定义值赋值）。（**初始化静态变量**）
4. **解析：**
   1. 将类的二进制数据流中的符号引用替换为直接引用（**本类中如果用到类其他类，此时就需要找到对应的类**）
5. **2+3+4=链接**
5. **初始化：**
   1. 根据程序员通过程序制定的**主管计划（静态代码块）**去初始化类变量和其他资源（**静态变量赋值以及初始化其他资源**）

##### 类加载器的分类

- 启动类加载器（Bootstrap ClassLoader）：虚拟机内置的类加载器（**加载Java核心类库中的类**）
- 平台类加载器（Platform ClassLoader）：负责加载JDK中一些特殊的模块（**加载Java拓展模块中的类**）
- 系统类加载器（System ClassLoader）：负责加载用户类路径上所指定的类库（**加载开发者编写的类以及开发者依赖的第三方类库**）

##### 双亲委派机制

目的：**保证每个类加载器都能加载到自己的应该加载的类，防止重复加载**

概念：当加载一个类的时候，首先默认交给系统类加载器加载，系统类加载器不会直接加载，会委派给自己的上层加载器进行加载，

每加载一个类都要逐层进行委派，委派给最上级的启动类，启动类通过分辨在逐级向下委派，直到找到对应的类加载器

##### 类加载器的获取与常用方法

| 方法名                                              | 说明                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| public static ClassLoader getSystemClassLoader()    | 获取系统类加载器                                             |
| public InputStream getResourceAsStream(String name) | 加载某一个资源文件，返回一个绑定src文件夹下指定名称文件的字节输入流 |

```java
//getResourceAsStream 注意事项
1.要绑定的源文件必须在src下（类加载器能够读取到的范围）
2.只需要在方法的参数处传递文件的名称即可（不需要写其他的路径）
    
结论：一般用于读取properties文件返回字节输入流，与Properties类的load方法搭配使用（最快完成文件内容的读取）
```



#### 反射

是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性

这种**动态获取**信息以及**动态调用**对象**方法**的功能称为Java语言的放射机制

- **利用反射可以无视修饰符获取类里面的所有属性和方法**
- **先获取配置文件中的信息，动态获取信息并创建对象和调用方法**

**结论：在运行阶段任意调用任何一个类的任何一个方法**

##### 获取class类的对象

1. Class.forName("全类名");（源码阶段时）
2. 类名.class（c lass对象已经在内存中时）
3. 对象.getClass();（已经创建好了类对象时）

##### 反射获取构造方法并使用

Class类中用于获取构造方法的方法

| 方法名                                                       | 说明                           |
| ------------------------------------------------------------ | ------------------------------ |
| Constructor<?>[] getConstructors();                          | 返回所有公共构造方法对象的数组 |
| Constructor<?>[] getDeclaredConstructors();                  | 返回所有构造方法对象的数组     |
| Constructor<T> getConstructor(Class<?>... parameterTypes);   | 返回单个公共构造方法对象       |
| Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes); | 返回单构造方法对象             |

Constructor类中用于创建对象的方法

| 方法名                             | 说明                         |
| ---------------------------------- | ---------------------------- |
| T newInstance(Object... initargs); | 根据指定的构造方法创建对象   |
| setAccessible(boolean flag)        | 设置为true，表示取消访问检查 |

**小结：**

- 获取class对象
  - 三种方式  ---- 推荐 **Class.forName("全类名")；**
- 获取里面的构造方法对象
  - getConstructor(Class<?>... parameterTypes);
  - getDeclaredConstructor(Class<?>... parameterTypes);
- 如果是public的，直接创建对象
  - newInstance(Object... initargs)
- 如果是非public的，需要临时取消检查，然后在创建对象
  - setAccessible(boolean);  **暴力反射**

##### 反射获取成员方法并运行

1. 先获得class对象

2. 获得Method对象

   | 方法名                                                       | 说明                                                         |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | Method[] getMethods();                                       | 返回所有公共成员方法对象的数组，包括继承的                   |
   | Method[] getDeclaredMethods();                               | 返回所有成员方法对象的数组，不包括继承的；每次运行获取的数组顺序不一致 |
   | Method getMethod(String name,Class<?>... parameterTypes);    | 返回单个公共成员方法对象                                     |
   | Method[] getDeclaredMethods(String name,Class<?>... parameterTypes); | 返回单个成员方法对象；推荐使用                               |

3. 运行方法

   1. Object invoke(Object obj,Object... args);参数一：用obj对象调用该方法，参数二：调用方法的传递的参数（如果没有就不写）；返回值：方法的返回值

#### 注解

也叫元数据

一种代码级别的说明，它是JDK1.5及以后引入的一个特性，与类、接口、枚举是在同一个层次

它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释

**本质就是一个接口，是一个实现类对象，该接口默认继承自Annotation接口**

| 注解名      | 说明                   |
| ----------- | ---------------------- |
| @Override   | 描述子类重写父类的方法 |
| @Deprecated | 描述方法过时           |

##### 注解的定义格式

```java
public @interface 注解名称{
	public 属性类型 属性名() default 默认值;
}
// 属性类型可以是：基本数据类型、String、Class、注解、枚举及以上类型的一维数组
```

##### 特殊属性值value

1. 当注解中只有一个属性且名称是value，在使用注解是给value属性赋值可以直接给属性值，无论value是单值元素还是数组类型
2. 如果注解中除了value属性还有其他属性，且至少有一个属性没有默认值，则在使用注解给属性赋值时，value属性名不能省略

##### 元注解

就是描述注解的注解

| 元注解名    | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| @Target     | 指定了注解能在哪里使用                                       |
| @Retention  | 可以理解为保留时间（生命周期）；自定义注解如果没标记此注解，则只存在于源码期 |
| @Inherited  | 表示修饰的自动有注解可以被子类继承                           |
| @Documented | 表示该自定义注解，会出现在API文档里面                        |

##### 注解的解析方式

通过Java技术获取注解数据的过程则称为注解解析

| 方法名                                             | 说明                                                      |
| -------------------------------------------------- | --------------------------------------------------------- |
| boolean isAnnotationPresent(Class annotationClass) | 判断当前对象是否有指定的注解，有则返回true，否则返回false |
| T getAnnotation(Class<T> annotationClass)          | 获得当前对象上指定的注解对象                              |
| Annotation[] getAnnotations()                      | 获得当前对象及其父类上继承的所有注解对象                  |
| Annotation[] getDeclaredAnnotations()              | 获得当前对象上所有的注解对象，不包括父类                  |

# 进阶第17天（MySQL）

#### JavaWeb

用Java技术来解决相关web互联网领域的技术栈

#### 数据库（DataBase：DB）

存储数据的仓库，数据是有组织的进行存储

#### SQL（Structred Query Language）

结构化查询语音

用于操作关系型数据库的统一规范

垂直分表：将一个表的字段分到多个表中

水平分表：将一个表的数据分到多个表中，多个表的字段一模一样
RestController是将controller的数据转换为json返回给前端

#### 关系型数据库

建立在关系模型上的数据库，是由多张能互相连接的**二维表**组成的数据库

1. 都是使用表结构，格式一致，易于维护
2. 使用通用的SQL语言操作，使用方便，可用于复杂查询
3. 数据存储在磁盘中，安全

**MySQL**数据库的数据**默认**在磁盘中保存的**数据结构叫做B+Tree** 

#### SQL语法

##### 注释

- 单行注释：--通用的注释语法    #MySQL独有的注释语法
- 多行注释：/* */

##### DDL语句

用来操作数据库/表/列的增删改查

1. 查询：

   1. 查看数据库：SHOW DATABASES;
   2. 查看当前数据库下的表：SHOW TABLES；
   3. 查看某个表的结构：DESC 表名；

2. 创建：

   1. 创建数据库：CREATE DATABASE 数据库名称；

      ```sql
      CREATE DATABASE 数据库名称;
      CREATE DATABASE IF NOT EXISTS cp_mac_399_ddl CHARACTER SET utf8;--指定编码格式
      ```

   2. 创建数据库（判断，如果不存在则创建）：CREATE DATABASE IF NOT EXISTS 数据库名称；

   3. 创建表：

      ```SQL
      CREATE TABLE 表名(
      	字段名1 数据类型1,
          ....
          字段名n 数据类型n
      );
      -- 最后一行末尾，不能加逗号
      
      ```
   
      

3. 删除：

   1. 删除数据库：DROP DATABASE 数据库名称；
   2. 删除数据库（判断，如果存在则删除）：DROP DATABASE IF EXISTS  数据库名称；
   3. 删除表：DROP TABLE 表名；
   4. 删除表（判断，如果存在则删除）：DROP TABLE IF EXISTS  表名；

4. 修改

   1. 修改表：

      ```SQL
      --修改表名
      ALTER TABLE 表名 RENAME TO 新表名;
      --添加一列
      ALTER TABLE 表名 ADD 列名 数据类型;
      --修改数据类型
      ALTER TABLE 表名 MODIFY 列名 新的数据类型;
      --修改列名和数据类型
      ALTER TABLE 表名 CHANGE 列名 新的列名 新的数据类型;
      --删除列
      ALTER TABLE 表名 DROP 列名;
      ```

      

5. 使用数据库

   1. 查看当前使用的数据库：SELECT DATABASE();
   2. 选择指定数据库：USE 数据库名称；

##### DML语句

用来操作表中的数据进行增删改

```sql
--给指定列添加数据
INSERT INTO 表名(列名1, ... ,列名n) VALUES(值1, ... ,值n);

--给全部列添加数据
INSERT INTO 表名 VALUES(值1, ... ,值n);

--批量添加数据
INSERT INTO 表名(列名1, ... ,列名n) VALUES(值1, ... ,值n),(值1, ... ,值n),(值1, ... ,值n);
INSERT INTO 表名 VALUES(值1, ... ,值n),(值1, ... ,值n),(值1, ... ,值n);

--修改表数据,如果不添加条件则将所有数据都修改
UPDATE 表名 SET 列名1=值1，列名2=值2，...[WHERE 条件];

--删除数据，如果不添加条件则将所有数据删除
DELETE FROM 表名 [WHERE 条件];
--清空表所有数据，并清空自增约束值
TRUNCATE TABLE 表名;

-- 条件的写法：列名 运算符 指定值
```



##### DQL语句

用来对表中的数据进行查询

1. 基础查询

   ```sql
   -- 查询多个字段，查询出来的是伪表
   SELECT 字段列表 FROM 表名;
   SELECT * FROM 表名;  -- 查询所有数据
   
   -- 去除重复记录，组合去重，如果查询的是多个字段则会将多个字段组合起来去重
   SELECT DISTINCT 字段列表 FROM 表名;
   
   -- 起别名
   AS:AS也可以省略
   SELECT name AS '姓名', gender AS '性别' FROM stus;
   SELECT name '姓名', gender '性别' FROM stus;
   ```

2. 条件查询

   ```sql
   SELECT 字段列表 FROM 表名 WHERE 条件列表;
   -- LIEK '%查询值%'：模糊查询 _单个任意字符，%多个任意字符
   -- BETWEEN 较小值 AND 较大值：在某个范围内就是>=&&<=
   -- IN(...)：多选一
   ```

3. 排序查询

   ```sql
   SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2]...;
   SELECT * FROM student ORDER BY birthday DESC;
   -- 排序方式：ASC升序排列（默认值）DESC降序排序
   -- 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序
   ```

4. 聚合函数

   将**一列数据**作为一个整体，进行纵向计算

   ```sql
   SELECT 聚合函数名(列名) FROM 表;
   -- null值不参与所以聚合函数运算
   ```

   | 函数名      | 功能                             |
   | ----------- | -------------------------------- |
   | count(列名) | 统计数量（一般选用不为null的列） |
   | max(列名)   | 最大值                           |
   | min(列名)   | 最小值                           |
   | sum(列名)   | 求和                             |
   | avg(列名)   | 平均值、                         |

5. 分组查询

   ```sql
   SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];
   SELECT gender,MAX(score) FROM student GROUP BY gender;
   -- 分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义；分组之后必查分组字段
   ```

   where和having的区别：

   - 执行时机不一样：where是分组之前进行限定，不满足where条件则不参与分组，而having是分组之后对结果见过滤。
   - 可判断的条件不一样：where不能对聚合函数进行判断，having可以

   执行顺序：where =》聚合函数 =》having

6. 分页查询

   ```sql
   SELECT 字段列表 FROM 表名 LIMIT 开始索引,结束索引;
   -- 起始索引：从0开始
   -- 开始索引计算公式：起始索引 = （当前页面-1）* 每页显示的条数
   LIMIT 是MySQL的方言
   ROWNUMBER 是Oracle的分页方言
   TOP 是SQL Server的分页方言
   ```

**注意：MySQL对于null值是不可以直接用 != 或者 = 来进行判断可以使用IS NULL / IS NOT NULL**

##### DCL语句

对数据库进行权限控制

# 进阶第18天

#### 约束

用于表中列上的规则，用于限制加入标的数据

约束的存在保证了数据库中数据的正确性、有效性和完整性

##### 约束的分类

| 约束名称 | 描述                                                         | 关键字         |
| -------- | ------------------------------------------------------------ | -------------- |
| 非空约束 | 保证列中的所有数据不能有NULL值                               | NOT NULLL      |
| 唯一约束 | 保证列中的所有数据各不相同（可以有**多个NULL**）             | UNIQUE         |
| 主键约束 | 主键是一行数据的唯一标识，要求非空且唯一（**可以多个列同时添加**组成联合主键，但还是**每一列**都**不能有重复**值，不是联合判断） | PRIMARY KEY    |
| 检查约束 | 保证列中的值满足某一条件（MySQL不支持）                      | CHECK          |
| 默认约束 | 保存数据时，未指定值则采用默认值                             | DEFAULT        |
| 外键约束 | 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性**（外键约束只是用于检索数据的完整性/一致性，有没有外键约束都不影响多表数据的查询）** | FOREIGN KEY    |
| 自增约束 | 能够作用于数据类型是INT的列上，核心功能：当自增约束**作用于INT类型的**列上的时候，在添加这列数据时，可以直接传递NULL（一个表**只能添加一个**，**truncate**会**重置自增**列） | AOTO_INCREMENT |

```sql
CREATE TABLE 表名(
	列名 数据类型 约束关键字
);

-- 创建完成表后添加约束(必须保证添加列没有NULL值，否则无法添加约束)
ALTER TABLE 表名 MODIFY 字段名 数据类型 约束关键字;

-- 添加主键
ALTER TABLE 表名 ADD PRIMARY KEY(字段名,...);
-- 删除约束(但删除后还是剩一个非空约束)
ALTER TABLE 表名 DROP PRIMARY KEY
;
-- 删除约束
ALTER TABLE 表名 MODIFY 字段名 数据类型;

-- 删除唯一约束
ALTER TABLE 表名 DROP INDEX 字段名;

-- 添加外键外 键名称使用（FK_DID_DID）
CONSTRAINT 外键名称 FOREIGN KEY (外键列名) REFERENCES 主表(主表列名)
```

#### 数据库设计

建立数据库中的表结构以及表与表之间的关联关系的过程

##### 表关系

- 一对一

  - 将一个表拆分，一个表存储常用的数据，另一个表存储不常用的数据
  - 推荐**在不常用的表**中维护关联关系（添加外键）

- 一对多（多对一）

  - ```sql
    CREATE TABLE emp(
    	eid INT PRIMARY KEY AUTO_INCREMENT,
    	ename VARCHAR(20) NOT NULL,
    	age TINYINT NOT NULL,
    	did INT,
    	CONSTRAINT FK_DID_DID FOREIGN KEY (did) REFERENCES dept(did) -- 添加外键约束
    );
    
    CREATE TABLE dept(
    	did INT PRIMARY KEY AUTO_INCREMENT,
    	dname VARCHAR(20) NOT NULL,
    	address VARCHAR(20) NOT NULL,
    );
    ```

    

- 多对多

  - 当表和表之间的数据是多对多关系，需要依赖第三张表来维护

##### 多表查询

从多张表查询数据

**笛卡尔积：**取表中所有交集的情况；当进行多表查询的时候，两张**表的数据产生的所有交集情况**组成笛卡尔积（表1数据 * 表2数据，就是总的数据）

##### 多表查询套路

1. 判断结果数据来源于哪些表
2. 获取数据源头组成的笛卡尔积
3. 观察笛卡尔积找到要保留数据的特征（那一列和那一列相同就保留）
4. 对结果和查询过程进行优化

##### 连接查询

###### 内连接：

相当于查询AB**交集的数据**；把两张或多张表连接在一起

```sql
-- 隐式内连接
SELECT 字段列表 FROM 表1,表2,... WHERE 条件;

-- 显式内连接
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;
```

###### 外连接：

1. 左外连接：相当于查询**左**表**所有数据**和**右表交集部分数据**
2. 右外连接：相当于查询**右表所有数据**和**左表交集部分数据**

```sql
-- 左外连接，查询表1全部内容，表2交集内容
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;
-- 右外连接
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;
```

###### 子查询

就是一个SQL查询的结果作为另一个SQL查询语句语法的一部分

```sql
-- 单行单列：作为条件值，使用 = != > <等进行条件判断
SELECT 字段列表 FROM 表名 WHERE 字段名= (子查询);

-- 多行单列：作为条件值，使用 in 等关键字进行条件判断
SELECT 字段列表 FROM 表名 WHERE 字段名 IN (子查询);

-- 多行多列：作为虚拟表
SELECT 字段列表 FROM (子查询) WHERE 条件;

SELECT dept.NAME,a.COUNT FROM dept INNER JOIN (SELECT dept_id,COUNT(dept_id) COUNT FROM emp GROUP BY dept_id) a ON dept.id=a.COUNT;
```

##### 事务

数据库的事务是一种机制、一个操作序列，包含了一组数据库操作命令

事务**把所有的命令**作为**一个整体**一起**向系统提交**或撤销操作**请求**，即这一组数据库命令**要么同时成功，要么同时失败**

```sql
-- 开启事务
START TRANSACTION; 或者 BEGIN;
-- 提交事务
COMMIT;
-- 回滚事务
ROLLBACK;
```

###### 四大特征

- **原子性**（Atomicity）：事务是不可分割的最小操作单位，要么同时成功，要么同时失败
- **一致性**（Consistency）：事务完成时，必须使所有的数据都保存一致状态
- **隔离性**（Isolation）：多个事务之间，操作的可见性
- **持久性**（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久性的

```sql
-- 查看事务的默认提交方式
SELECT @@autocommit;
-- 1 自动提交 0 手动提交 多条SQL使用手动提交，单条SQL使用自动提交
SET @@autocommit = 0;
```

# 进阶第19天

#### JDBC（Java DataBase Connectivity）

是使用JAVA语言操作**关系型数据库**的一套API（接口）各大数据库厂商实现这套接口，提供对应的Jar包

通过JDBC去操作数据库的时候除了要有Java本身的规范，还要有数据库厂商提供的具体的驱动Jar包

**本质就是Java提供的套接口，各大数据库厂商实现了这套接口**

##### 使用步骤

```java
//1.导入Jar包
mysql-connector-java-5.1.48.jar
//2.注册驱动
Class.forName("com.mysql.jdbc.Driver");
//3.获取连接
Connection conn = DriverManager.getConnection(url,username,password);
//4.定义SQL语句
String sql = "update...";
//5.获取执行SQL对象
Statement stmt = conn.createStatement();
//6.执行SQl
stmt.executeUpdate(sql);
//7.处理返回结果
//8.释放资源
```

##### DriverManager

- 注册驱动：**Class.forName("com.mysql.jdbc.Driver");**

  - MySQL 5 之后的驱动包，可以省略注册驱动的步骤：DriverManger.registerDriver(new Driver());

  - 自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类

- 获取连接;**Connection conn = DriverManager.getConnection(url,username,password);**
  - 参数url：连接路径，格式：**jdbc : mysql : // 数据库服务器IP地址 : 数据库的运行端口号 / 数据库的名称 ？配置参数名1 = 配置参数值1 & 配置参数名2 = 配置参数名2 ...**
  - 参数user：用户名
  - 参数password：密码

##### Connection

- 获取执行SQL对象

  - ```sql
    -- 普通执行SQL对象
    Statement createStatement();
    -- 预编译SQL的执行SQL对象：防止SQL注入
    PreparedStatement prepareStatement(sql);
    -- 执行存储过程的对象
    CallableStatement   prepareCall(sql);
    ```
  
- 管理事务

  - ```sql
    -- MySQL事务管理
    -- 开启事务
    START TRANSACTION; 或者 BEGIN;
    -- 提交事务
    COMMIT;
    -- 回滚事务
    ROLLBACK;
    
    -- JDBC事务管理
    -- 开启事务
    setAutoCommit(boolean autoCommit); true为自动提交事务，false为手动提交事务，即为开启事务
    -- 提交事务
    commit();
    -- 回滚事务
    rollback();
    
    -- 将操作SQL的语句使用try环绕捕获异常
    ```
    

##### Statement

执行SQL语句

```java
int executeUpdate(sql);//执行DML、DDL语句，返回1.DML语句影响的行数，2.DDL语句执行后，执行成功也可能返回0

ResultSet executeQuery(Sql);//执行DQL语句，返回ResultSet对象
```

##### ResultSet

**封装了DQL查询语句的结果**

```java
//获取查询结果
//将光标从当前位置向前移动一行
//判断当前是否为有效行
boolean next();//返回true有效false无效

//获取数据
xxx getXxx(参数);//xxx为数据类型，如 int getInt(参数);

//使用步骤：
//游标向下移动一行，并判断该行否有数据：next()
//获取数据：getXxx(参数)
//循环判断游标是否是最后一行末尾
while(rs.next()){
    //获取数据
    rs.getXxx(参数);
}
```

##### PreparedStatement

**预编译SQL语句**并执行：预防SQL注入问题，对敏感字符进行转义，如**1' OR '1' = '1，会转义为 1\ ' OR \ '1\ ' = \ '1**

注意事项：

1. 预编译SQL：本质上就是一条SQL语句，在Java中的体现就是String字符串，特点：如果可以明确SQL语句中所有部分，那么直接编写即可，如果有部分内容不能明确则使用 ？进行占位。

```java
// 获取 PreparedStatement 对象
// SQL语句中的参数值，使用？占位符替代
String sql = "select * from user where username = ? and password = ?";
// 通过Connection对象获取，并传入对应的sql语句
PreparedStatement pstmt = conn.prepareStatement(sql);

//设置参数值
PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值
Xxx：数据类型 ； 如 setInt (参数1，参数2)
参数：
参数1： ？的位置编号，从1 开始
参数2： ？的值

//执行SQl
executeUpdate(); //DML语句使用（增删改），不需要再传递sql

executeQuery(); //DQL语句使用（查询）

//释放资源，
```

##### 数据库连接池

是一个管理数据库连接对象的容器

**好处：**

1. 提高连接的重用性（可以重复使用一个数据库连接对象）
2. 提高系统的响应速度（避免每次创建连接对象的消耗时间）
3. 统一对数据库连接进行管理，避免遗漏

- 标准接口：DataSource（**Java官方提供的规范接口，第三方组织实现该接口，来实现连接池**）

  ```java
  //获取连接
  Connection getConnection();
  ```

- 常见的数据库连接池

  - DBCP、C3P0、Druid
  - Druid（德鲁伊）是阿里巴巴开源的数据库连接池项目

##### DRUID连接池的使用

1. 将Druid配置文件相关信息读取到Properties集合中
2. 通过DruidDataSourceFactory静态方法，将Properties集合作为参数传递，返回一个创建好的连接池对象
3. 通过创建好的连接池对象来获取Connection连接

```java
//1.将Druid配置文件相关信息读取到Properties集合中
//properties配置文件内容如下
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/cp_399_jdbc?useSSL=false
username=root
password=a15932780581
//初始化连接池数量
initialSize=5
//最大连接数
maxActive=10
//最大等待时间
maxWait=3000
//2.通过DruidDataSourceFactory静态方法，将Properties集合作为参数传递，返回一个创建好的连接池对象
    Properties prop = new Properties();
    prop.load(ClassLoader.getSystemClassLoader().getResourceAsStream("db.properties"));
    dataSource = DruidDataSourceFactory.createDataSource(prop);
//3.通过创建好的连接池对象来获取Connection连接
	Connection conn = dataSource.getConnection();
```

##### druid配置详解


|                   属性                   |                             说明                             |          建议值           |
| :--------------------------------------: | :----------------------------------------------------------: | :-----------------------: |
|                   url                    |   数据库的jdbc连接地址。一般为连接oracle/mysql。示例如下：   |                           |
|                                          |    mysql : jdbc:mysql://ip:port/dbname?option1&option2&…     |                           |
|                                          |        oracle : jdbc:oracle:thin:@ip:port:oracle_sid         |                           |
|                                          |                                                              |                           |
|                 username                 |                      登录数据库的用户名                      |                           |
|                 password                 |                     登录数据库的用户密码                     |                           |
|               initialSize                |            启动程序时，在连接池中初始化多少个连接            |        10-50已足够        |
|                maxActive                 |                连接池中最多支持多少个活动会话                |                           |
|                 maxWait                  | 程序向连接池中请求连接时,超过maxWait的值后，认为本次请求失败，即连接池 |            100            |
|                                          |         没有可用连接，单位毫秒，设置-1时表示无限等待         |                           |
|        minEvictableIdleTimeMillis        | 池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时，将 |        见说明部分         |
|                                          |               回收该连接,要小于防火墙超时设置                |                           |
|                                          |   net.netfilter.nf_conntrack_tcp_timeout_established的设置   |                           |
|      timeBetweenEvictionRunsMillis       |    检查空闲连接的频率，单位毫秒, 非正整数时表示不进行检查    |                           |
|                keepAlive                 | 程序没有close连接且空闲时长超过 minEvictableIdleTimeMillis,则会执 |           true            |
|                                          | 行validationQuery指定的SQL,以保证该程序连接不会池kill掉,其范围不超 |                           |
|                                          |                  过minIdle指定的连接个数。                   |                           |
|                 minIdle                  |          回收空闲连接时，将保证至少有minIdle个连接.          |     与initialSize相同     |
|             removeAbandoned              | 要求程序从池中get到连接后, N 秒后必须close,否则druid 会强制回收该 |   false,当发现程序有未    |
|                                          | 连接,不管该连接中是活动还是空闲, 以防止进程不会进行close而霸占连接。 | 正常close连接时设置为true |
|          removeAbandonedTimeout          | 设置druid 强制回收连接的时限，当程序从池中get到连接开始算起，超过此 |  应大于业务运行最长时间   |
|                                          |            值后，druid将强制回收该连接，单位秒。             |                           |
|               logAbandoned               |    当druid强制回收连接后，是否将stack trace 记录到日志中     |           true            |
|              testWhileIdle               | 当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效) |           true            |
|             validationQuery              | 检查池中的连接是否仍可用的 SQL 语句,drui会连接到数据库执行该SQL, 如果 |                           |
|                                          |         正常返回，则表示连接可用，否则表示连接不可用         |                           |
|               testOnBorrow               |  程序 **申请** 连接时,进行连接有效性检查（低效，影响性能）   |           false           |
|               testOnReturn               |  程序 **返还** 连接时,进行连接有效性检查（低效，影响性能）   |           false           |
|          poolPreparedStatements          |                缓存通过以下两个方法发起的SQL:                |           true            |
|                                          |    public PreparedStatement prepareStatement(String sql)     |                           |
|                                          |    public PreparedStatement prepareStatement(String sql,     |                           |
|                                          |         int resultSetType, int resultSetConcurrency)         |                           |
| maxPoolPrepareStatementPerConnectionSize |                  每个连接最多缓存多少个SQL                   |            20             |
|                 filters                  |                这里配置的是插件,常用的插件有:                |      stat,wall,slf4j      |
|                                          |                    监控统计: filter:stat                     |                           |
|                                          |              日志监控: filter:log4j 或者 slf4j               |                           |
|                                          |                   防御SQL注入: filter:wall                   |                           |
|            connectProperties             |         连接属性。比如设置一些连接池统计方面的配置。         |                           |
|                                          |    druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000    |                           |
|                                          |                 比如设置一些数据库连接属性:                  |                           |
|                                          |                                                              |                           |

##### Druid工具类的抽取

1. 先创建工具类
2. 定义一个DataSource静态对象
3. 定义一个静态代码块，里面创建DataSource对象赋值给成员变量
4. 创建一个返回值是Connection对象的静态方法

```java
//1. 先创建工具类
public class DruidDataSourceUtil {
    //2. 定义一个DataSource静态对象
    private static DataSource dataSource;
    private DruidDataSourceUtil(){}
	//3. 定义一个静态代码块，里面创建DataSource对象赋值给成员变量
    static {
        try {
            Properties prop = new Properties();
            prop.load(ClassLoader.getSystemClassLoader().getResourceAsStream("db.properties"));
            dataSource = DruidDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    //4. 创建一个返回值是Connection对象的静态方法
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }
}

```

# 进阶第20天（Maven,MyBatis）

#### Maven

是专门用于管理和构建Java项目的工具

主要功能：

1. 提供了一套标准化的项目结构
2. 提供了一套标准化的构建流程（编译，测试，打包，发布）
3. 提供了一套依赖管理机制

##### 安装配置

1. 解压apache-maven.rar即为安装完成

2. 配置环境变量MAVEN_HOME为安装路径的bin目录

3. 配置本地仓库：修改conf/settings.xml中的<localReposiyory>为一个指定目录

4. 配置阿里云私服：修改conf/settings.xm中的<mirrors>标签，为其添加如下子标签：

   ```xml
   <mirror>
     <id>aliyunmaven</id>
     <mirrorOf>*</mirrorOf>
     <name>阿里云公共仓库</name> 			
     <url>https://maven.aliyun.com/repository/public</url>
   </mirror>
   ```

##### Maven常用命令

- compile：编译
- clean：清理
- test：测试
- package：打包
- install：安装

##### Maven生命周期

构建项目生命周期描述的的是一次**构建过程**经历了**多少个事件**

Maven对项目的构建生命周期划分为3套

1. clean：清理工作
2. default：核心工作，如编译，测试，打包，安装等
3. site：产生报告，发布站点等

**注：同一生命周期内，执行后边的命令，前面的所有命令会自动执行**

##### Maven坐标详解

是资源的唯一标识

使用坐标来定义项目或引入项目中需要的依赖

###### 坐标主要组成

- groupId：定义档期Maven项目隶属组织名称（通常是反写域名）

- artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）

- version：定义当前项目版本号

  - 版本号：推荐使用X.Y.Z-INFO
    - X：大版本（IDEA2020 2021 2022）
    - Y：中期版本（IDEA2020.1 2020.2 2020.3）
    - Z：小版本（IDEA2020.1.1 IDEA2020.1.2）
    - INFO：当前版本状态
      - SNAPSHOT：快照班/不稳定版
      - RELEASE：正式版
      - FIXBUG：Bug修复版
  
  
  ```xml
  <dependency>
  	<grouoId>mysql</grouoId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.46</version>
  </dependency>
  ```
  
- 使用指定Java版本编译

  - ```xml
    <!-- 与dependencies平级-->
        <build>
            <!-- 管理插件标签-->
            <plugins>
                <!-- 插件坐标-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.1</version>
                    <!-- 指定插件的具体配置项-->
                    <configuration>
                        <target>8</target>
                        <source>8</source>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    ```

##### IDEA配置Maven环境

1. 选择IDEA中File =》Settings
2. 搜索maven
3. 设置IDEA使用本地安装的Maven，并修改配置文件路径

###### IDEA创建Maven项目

1. 创建模块，选择Maven，点击Next
2. 填写模块名称，坐标信息，点击finish

###### IDEA导入Maven项目

1. 选择右侧Maven面板，点击+号
2. 选中对应项目的pom.xml文件，双击即可
3. 如果没有Maven面板，选择View =》Appearance =》Tool Windows Bars

###### 配置Maven-Helper插件

1. 选择IDEA中File =》Settings
2. 选择Plugins
3. 搜索Maven，选择第一个Maven-Helper，点击Install

###### 依赖管理

使用坐标导入jar包

1. 在pom.xml中编写<dependencies>标签（**只能有一个该标签**）
2. 在<dependencies>中使用<dependency>标签
3. 定义坐标中的groupId，artifactId，version

###### 依赖范围

通过设置坐标的依赖范围**scope标签**，可以设置对应Jar包的作用范围：编译环境，测试环境，运行环境

1. compiler：默认的依赖范围（源码/测试/打包）
2. test：测试依赖范围（测试代码不会打包）
3. provided：不参与打包依赖范围（测试源码都能用，但最终打包时不参与）

| 依赖范围      | 编译classpath            | 测试classpath | 运行classpath | 例                |
| ------------- | ------------------------ | ------------- | ------------- | ----------------- |
| compile默认值 | Y                        | Y             | Y             | logback           |
| test          | -                        | Y             | -             | Junit             |
| provided      | Y                        | Y             | -             | servlet-api       |
| runtime       | -                        | Y             | Y             | jdbc驱动          |
| system        | Y                        | Y             | -             | 存储在本地的jar包 |
| import        | 引入DependencyManagement |               |               |                   |

###### 依赖冲突：

1. 第一声明优先原则
2. 路径近者优先（直接 > 间接）

###### 依赖版本管理

```xml
	<dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>5.2.10.RELEASE</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

###### 模块继承

###### 模块聚合

#### MyBatis

是一款优秀的**持久层框架**，用于简化JDBC开发，ORM（表和对象的关系映射）框架，只专注与于sql语句

[MyBatis官网]: https://mybatis.org/mybatis-3/zh/index.html

###### 持久层

- 负责将数据保存到数据库的那一层代码
- JavaEE三层架构：表现层，业务层，持久层

###### 框架

- 框架就是一个半成品软件，是一套可复用的、通用的、软件基础代码模型
- 在框架的基础上构建软件编写更加高效、规范、通用、可扩展

##### MyBatis使用方式MyBatis核心配置文件

1. **导入MyBatis依赖的相关jar包**

   1. mysql驱动包
   2. Druid连接池（非必要）
   3. MyBatis核心包

2. **配置文件：框架的配置信息**

   1. 在resources目录下创建MyBatis的核心配置文件（XML）mybatis-config.xml

   2. 核心配置文件中编写的内容满足MyBatis的要求（**导入约束**）

      ```xml
      <?xml version="1.0" encoding="UTF-8" ?>
      <!DOCTYPE configuration
              PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
              "https://mybatis.org/dtd/mybatis-3-config.dtd">
      <!-- 由于在导入约束的时候已经指定了configuration必须作为根标签 -->
      <configuration>
          <!-- 在核心配置文件中指定Mybatis要连接数据库的基本信息 -->
          <!-- <environments>:数据源管理标签(可以编写多个)<environment>,default:默认使用哪个Id的数据库连接信息-->
          <environments default="mysql">
              <!-- <environment>表示一组具体的数据库连接信息,id:组数据库信息的名称 -->
              <environment id="mysql">
                  <!-- <transactionManager>事务管理器 type:JDBC(使用JDBC本身的提交回滚管理事务)-->
                  <transactionManager type="JDBC"/>
                  <!-- <dataSource>指定数据源 type:POOLED(使用连接池) -->
                  <dataSource type="POOLED">
                      <!-- <property>指定数据库的连接基本信息(驱动类/数据库连接地址)-->
                      <property name="driver" value="com.mysql.jdbc.Driver"/>
                      <property name="url" value="jdbc:mysql://127.0.0.1:3306/cp_399_mybatis?useSSL=false"/>
                      <property name="username" value="root"/>
                      <property name="password" value="root"/>
                  </dataSource>
              </environment>
          </environments>
      </configuration>
      ```

      

3. 创建SqlSessionFactoryBuilder读取核心配置文件，**创建SqlsessionFactory工厂**

   1. Resources（Mybatis）类：读取核心配置文件返回绑定了核心配置文件的输入流（**Resources.getResourcesAsStream("配置文件名")**）
   2. 创建**SqlSessionFactoryBuiler类对象，使用build(传入1的返回值字节输入流)**方法，创建SqlSessionFactory工厂类

4. **通过SqlSessionFactory工厂获取SqlSession连接对象**

   1. public SqlSession openSession()
   2. public SqlSession openSession(boolean flag)

5. **SqlSession使用方式**

   1. 创建配置文件：

      1. 命名xxxMapper.xml

      2. 导入约束

         ```xml
         <?xml version="1.0" encoding="UTF-8" ?>
         <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
         ```

      3. 给Mapper的<mapper>标签的namespace属性指定值（和其他的配置文件不重复）

      4. 在<mapper>标签中编写<select>标签并指定id属性值

      5. 编写SQL语句

         ```xml
         <!-- 指定SQL映射文件的名称 -->
         <mapper namespace="UserMapper">
             <select id="selectBlog" resultType="com.jwpeng.entity.User">
                 select * from user
             </select>
         </mapper>
         ```

      6. 在Mybatis核心配置中使用<mapper>标签进行管理

   2. **成员方法**：

      ```java
      Object selectOne(String statement)
      Object selectOne(String statement,Object o)
      List selectList(String statement)
      List selectList(String statement,Object o)
      int insert(String statement)
      int insert(String statement,Object o)
      int delete(String statement)
      int delete(String statement,Object o)
      int update(String statement)
      int update(String statement,Object o)
      ```

      1. **使用方法：**

         1. 根据SQL来进行判断使用哪个方法

         2. 方法的参数1：要执行的映射文件的namespace的SQL的id

         3. 方法的参数2：是否要传递数据给要执行的SQL语句，是就传

            1. **传简单数据：基本类型，字符串，日期**SQL语句通过**#{占位符}**来接收参数传递过来的值
            2. **传复杂数据（Java对象**）：

            ```xml
            <!-- 简单数据 -->
            <select id="selectByName" resultType="com.jwpeng.entity.User">
                    select * from user WHERE username= #{占位符};<!-- <>需要转义字符 -->
            </select>
            <!-- 复杂数据 -->
            <insert id="insert" resultType="com.jwpeng.entity.User" useGeneratedKeys="true"keyProperty="id">
                INSERT INTO user VALUE(#{成员变量},#{成员变量},#{成员变量}); 
            </insert>
            <!-- 
            返回添加数据的主键  
            useGeneratedKeys="true" 开启返回添加数据库后的主键值
            keyProperty="id" 将数据库添加刚刚添加数据的id字段的值返回给 参数对应的属性
            -->
            
            ```
            
            

6. SQL核心映射文件的属性：当进行查询语句的时候，查询到的**结果如果可以用一个类对象来表示，可以指定映射关系**，让MyBatis自动完成映射！**指定映射类必须和表列字段一一对应**

```java
		InputStream in = Resources.getResourceAsStream("mybatis-config.xml");
        
        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();
        
        SqlSessionFactory sqlSessionFactory = ssfb.build(in);

        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        System.out.println(sqlSession);
        
        List<Object> objects = sqlSession.selectList("UserMapper.selectAll");
        for (Object object : objects) {
            System.out.println(object);
        }
```

#### 动态代理

特点：只要有接口.，任意一个对象都可以进行增强. 

##### Mapper代理开发

1. 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下
2. 设置SQL映射文件的namespace属性为Mapper接口全限定名
3. 在Mapper接口中定义方法，方法名就是SQL映射文件中SQL语句的id，并保持参数类型和返回值类型一致
4. 编码：
   1. 通过SqlSession的getMapper方法获取Mapper接口的代理对象
   2. 调用对应方法完成sql的执行

**注意：如果Mapper接口名称和SQL映射文件名称相同，并且在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载**

##### MyBatis核心配置文件的配置项

- **日志开启：**

  - 导入log4j包

- **抽取核心配置**

  1. 在resources文件夹下新建一个.peoperties文件用于保存重要的配置信息

  2. 将重要信息按照KEY_VALUE的方式在文件中声明

  3. 将此配置文件引入MyBatis配置中

  4. 在核心配置中获取引入文件中的各项配置

     ```xml
     <!-- 3. 与<environments>标签平级-->
     <properties resource="org/mybatis/example/config.properties"/>
     
     <!-- 4. -->
     <dataSource type="POOLED">
       <property name="driver" value="${driver}"/>
       <property name="url" value="${url}"/>
       <property name="username" value="${username}"/>
       <property name="password" value="${password}"/>
     </dataSource>
     ```

- **取别名与批量取别名**

  1. 单独给一个指定的类取别名

     ```xml
     <typeAliases>
       <typeAlias alias="Author" type="domain.blog.Author"/>
     </typeAliases>
     ```

  2. **批量取别名**

     ```xml
     <!-- 指定一个包，默认使用小驼峰模式来取别名 -->
     <typeAliases>
       <package name="domain.blog"/>
     </typeAliases>
     
     <!-- 添加注释并取别名，每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名 -->
     @Alias("author")
     public class Author {
         ...
     }
     ```

     

##### MyBatis接口代理XML开发模式

三层结构：表现层，服务层，持久层（Dao/Mapper）

###### 使用步骤

1. 编写持久层接口（创建持久层接口）
2. 再接口中编写抽象方法
3. daw
   1. 创建接口映射的接口文件
   2. 编写文件的约束名：namespace绑定的是接口
   3. 在编写Mapper中绑定接口中的方法：**有几个方法就写几个SQL**
   4. **resultType的**值是：接口方法的返回值
   5. 完成SQL语句的编写

##### MyBatis接口代理的参数传递方式

###### 映射表和类的绑定

1. 简单方式：查询数据列名和成员变量名不一致时：**让SQL语句起别名（变成成员变量名）**

2. MyBatis推荐方式：手动指定映射关系

   ```xml
   <!-- property映射类成员变量名，column表列名 -->
   <resultMap id="blogResult" type="Blog">
       <!-- 主键 -->
     <id property="id" column="blog_id" />
       <!-- 其他列 -->
     <result property="title" column="blog_title"/>
     <collection property="posts" ofType="Post" resultMap="blogPostResult" columnPrefix="post_"/>
   </resultMap>
   
   
   <settings>
           <!--将以下画线方式命名的数据库列映射到 Java 对象的驼峰式命名属性中-->
           <setting name= "mapUnderscoreToCamelCase" value="true" />
   </settings>
   ```

   ```xml
   	返回一个Map （id = resultSetmeal）将查出来的值返回给这个Map
   	<select id="selectById" resultMap="resultSetmeal">
           SELECT * from t_setmeal WHERE id = #{id}
       </select>
   
   
       <resultMap id="resultSetmeal" type="com.itheima.health.pojo.Setmeal">
           这个checkGroups的属性由selectByGroup这个id的SQL语句查出来
           <collection property="checkGroups" ofType="com.itheima.health.pojo.CheckGroup" select="selectByGroup" column="setmealid = id"/>
       </resultMap>
   
   
       <select id="selectByGroup" resultMap="checkGroup">
           SELECT c.* FROM t_checkgroup c Left Join t_setmeal_checkgroup sc ON c.id = sc.checkgroup_id WHERE sc.setmeal_id = #{setmealid}
       </select>
   
   
   
       <resultMap id="checkGroup" type="com.itheima.health.pojo.CheckGroup">
           <collection property="checkItems" select="selectByItem" column="item = id"/>
       </resultMap>
   
   
   
       <select id="selectByItem" resultType="com.itheima.health.pojo.CheckItem">
           SELECT c.* FROM t_checkitem c LEFT JOIN t_checkgroup_checkitem cc ON c.id = cc.checkitem_id WHERE cc.checkgroup_id = #{item}
       </select>
   ```

   

3. MyBatis核心配置文件批量管理映射文件：

   ```xml
   在<mappers>标签中使用<package>标签指定一个文件夹，自动管理文件夹中的所有Mapper文件
       注意：指定文件夹一定要是和映射类的文件路径一致，保证编译后Mapper.xml和映射类处于同一文件夹下，创建时需一级一级创建
   <mappers>
   	<package name="com.jwpeng.mapper"/>   
   </mappers>
   ```

###### 映射表和类的参数传递

- 单个简单参数：
  1. 在mapper接口的方法中**参数前**需要添加注解**@Param("占位名")**
  2. 在xml文件中的SQL语句中使用这个占位名**#{占位名}**

- 多个简单参数

  1. 在mapper接口的方法中**参数前**需要添加注解**每个参数都需要添**加**@Param("占位名")**
  2. 在xml文件中的SQL语句中使用这个占位名**#{占位名}**

- 一个复杂参数（JavaBean）

  1. 在mapper接口的方法中**参数前**需要添加注解**每个参数都需要添**加**@Param("占位名")**（不加也行，使用对象名）
  2. 在xml文件中的SQL语句中使用这个占位名**#{占位名.变量名}**

- Map集合复杂参数

  1. 当有多个数据，但是多个数据不存在关联关系，可以通过Map

  2. 通过Param名.KEY名获取到Value

     ```xml
     <!-- Mapper接口中的抽象方法 -->
     List<Laptop> selectByLimit(@Param("prametmap")Map map);
     
     <!-- resultMap是查询到数据后返回的类型 parameterType是抽象方法传递的参数类型 -->
     <select id="selectByLimit" resultMap="laptop2laptop" parameterType="map">
             SELECT * FROM laptop WHERE price &gt; #{prametmap.price} LIMIT #{prametmap.startIndex},#{prametmap.size};
         </select>
     ```

     

##### MyBatis注解完成增删改查	

- @Select
- @Update
- @Insert
- @Delete

```java
// 添加笔记本电脑信息
@Insert("INSERT INTO laptop VALUES (#{laptop.id}, #{laptop.brand}, #{laptop.type}, #{laptop.price}, #{laptop.count}, #{laptop.cpu},#{laptop.memory},#{laptop.size}, #{laptop.disk}, #{laptop.joinDate})")
void insertLaptop(@Param("laptop") Laptop laptop);

// 查询全部笔记本电脑信息
@Select("SELECT id, brand, type, price, count, cpu, memory, size, disk, join_date AS joinDate FROM laptop")
List<Laptop> selectAll();

// 根据Id查询笔记本电脑信息
@Select("SELECT id, brand, type, price, count, cpu, memory, size, disk, join_date joinDate FROM laptop WHERE id=#{id}")
Laptop selectById(@Param("id") Integer id);

// 根据指定品牌查询笔记本电脑信息
@Select("SELECT * FROM laptop WHERE brand=#{brand}")
@Results(id="lap2lap" ,value={
	@Result(column = "join_date",property = "joinDate")
})
List<Laptop> selectByBrand(@Param("brand") String brand);

// 根据价格区间查询笔记本电脑信息
@Select("SELECT * FROM laptop WHERE price BETWEEN #{priceStart} AND #{priceEnd}")
@ResultMap("lap2lap")
List<Laptop> selectByPrice(@Param("priceStart") Double priceStart, @Param("priceEnd") Double priceEnd);
```



##### MyBatis的动态SQL

根据条件拼接乘不同的SQL语句

- <sql>
  
  - 当SQL映射文件中有大量的重复SQL语句，单独抽取出来**<sql id="cid">重复内容</sql>**
  - SQL语句中使用**<include refid="cid"/>**来引用
- <if>
  
  - 判断，成功就拼接，否则不拼接**<if test="判断条件">SQL语句</if>**判断条件直接使用传递的参数值**不需要加#{}**
  - 如果所有的条件都是<if>拼接，如果所有条件不满足则会出现SQL语句的拼接问题（使用WHERE标签解决）
- <where>
  
  - 可以灵活根据是否存在条件，完成WHERE的拼接，会自动去掉多于的**前AND**，但不会自动添加，所有需要添加**前AND**
- <set>
  
  - 同<where>
  
- <foreach>

  - ```xml
     <!--
             void deleteByIds(@Param("ids") int[] ids);
           批量删除
          <foreach>
           collection="array"数组默认写 array 集合写list
              如果 我们数组变量 定义了 @Param
              @Param叫啥写啥
           open 遍历前拼接的内容
           close 遍历后拼接的内容
           separator 元素之间分割符
            item  接收遍历出来的变量
            #{id} 取出变量值
        -->
        <delete id="deleteByIds">
            delete from tb_brand
               where id  in
                   <foreach collection="ids" open="(" close=")" separator="," item="id">
                       #{id}
                   </foreach>
        </delete>
    ```

    


# 进阶第21天（HTML，CSS）

#### HTML

标记语言

##### 结构

```html
<html>
	<head>
		<title></title>
	</head>
	<body>
	</body>
</html>
<!-- 内容写在body标签中 -->
```

| **标签名** | **定义**   | **说明**                                                     |
| ---------- | ---------- | ------------------------------------------------------------ |
| <h1>-<h6>  | 标题标签   | 作为标题使用，根据重要性递减                                 |
| <p></p>    | 段落标签   | 定义段落，可以将网页分成若干段落                             |
| <br/>      | 换行标签   | 强制换行                                                     |
| <hr/>      | 水平线标签 | 定义  HTML 页面中的主题变化（比如话题的转移），并显示为一条水平线。 |
| <b></b>    | 加粗标签   | 定义粗体的文本                                               |
| <i></i>    | 斜体标签   | 定义呈现斜体的文本                                           |
| <u></u>    | 下划线标签 |                                                              |

##### 超链接标签

<a href="跳转目标" target="目标窗口弹出">

| 属性值 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| src    | 设置的是图片地址，写的是服务器地址（不能使用盘符来访问图片，会暴露全部计算机中的资源） |
| alt    | 如果图片丢失，替代的文字                                     |
| title  | 如果鼠标移动上去，显示的图片图示                             |
| width  | 宽度，如果只指定宽度，另一个按等比例缩放                     |
| height | 高度                                                         |
| href   | 必须属性，用来指定链接到达的地址                             |
| target | 解决在哪里打开：self默认，在当前窗口打开；blank在新的窗口中打开鼠标移动上去，显示提示信息 |

##### 表格标签

```html
<table>
    <tr>表格中的行
    	<td>内容</td>表格中的列（单元格）
        ...
    </tr>
</table>
```

| 属性名      | 属性值              | 描述                                             |
| ----------- | ------------------- | ------------------------------------------------ |
| align       | left、center、right | 规定表格相对周围元素的对齐方式                   |
| border      | 1或“’               | 规定表格单元是否拥有边框，默认为”“，表示没有边框 |
| cellpadding | 像素值              | 规定单元边沿与其内容直接的空白，默认1像素        |
| cellspacing | 像素值              | 规定单元格之间的空白，默认2像素                  |
| width       | 像素值或百分比      | 规定表格的宽度                                   |

##### 列表标签

```html
别表标签可以添加一个type属性（I，A）、

无序列表
<ul>
    <li>列表项1</li>
    <li>列表项2</li>
    <li>列表项3</li>
</ul>
有序列表
<ol type="I"(type="A")>
    <li>列表项1</li>
    <li>列表项2</li>
    <li>列表项3</li>
</ol>


自定义列表
<dl>
	<dt>刘备</dt>
	<dd>关羽</dd>
</dl>
<dl>
	<dt>关注我们</dt>
    <dd>新浪微博</dd>
    <dd>微信公众号</dd>
</dl>
```

##### Form表单

```html
<form action="url地址" method="提交方式" name="表单域名称">
    各种表单控件
</form>
```

| 属性   | 属性值   | 作用                                               |
| ------ | -------- | -------------------------------------------------- |
| action | url地址  | 用于指定接受并处理表单数据的服务器程序的url地址    |
| method | get/post | 用于设置表单数据的提交方式，其取值为get或post      |
| name   | 名称     | 用于指定表单的名称，一区分同一个页面中的多个表单域 |

###### 表单标签

```html
<input type="" name="" value="" checker="checker">
1.name和value是每个表单元素都有的属性，主要给后台人员使用
2.name表单元素的名字，要求单选按钮和复选框要有相同的name值
3.checked属性主要针对对于单选按钮和复选框，主要作用一打开页面，就可以默认选中某个表单元素。

```

| type的属性值 | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| button       | 定义可点击按钮                                               |
| checkbox     | 定义复选框                                                   |
| file         | 定义输入字段和“浏览”按钮，供上传文件                         |
| hidden       | 定义隐藏的输入字段                                           |
| image        | 定义图像形式的提交字段                                       |
| password     | 定义密码字段。字段中的字符被掩码                             |
| radio        | 定义单选按钮（多选一）                                       |
| reset        | 定义重置按钮，重置按钮会                                     |
| submit       | 定义提交按钮，提交按钮会把表单数据发送到服务器               |
| text         | 定义单行的输入字符，用户可在其中输入文本，默认宽度为20个字符 |

###### 下拉列表

```html
<select>
    <option>选项1</option>
    <option>选项2</option>
    ....
</select>
1.select中至少包括一对option。
2.在中定义selected="selected"时，当前项即为默认选中项。
```



###### 多行文本框

```html
<textarea rows="3" cols="20">
1：通过<textarea>标签可以轻松地多行文本输入框
2：cols=“每行中的字符数“，rows=”显示的行数“，我们在实际开发中不会使用，都是用css来改变大小

```



#### CSS

是用于指定CSS样式的Html标签

```css
选址器{
	属性1;
	....
}
```

##### 引入方式

1. 内部样式表

   ```html
   <style>
       选择器（标签选择器，Id选择器，class选择器，通用选择器）{
           属性1;
           ...
       }
   </style>
      1：<style>标签理论上可以放在HTML文档的任何地方，但一般会放在文档的<head>标签中。
      2：该方式使代码结构清晰，但是并没有实现结构与样式完全分离。
   
   ```

2. 行内样式表

   ```css
   <div style="color:red; font-size:12px;">行内样式表</div>
      1：style其实就是标签的属性。
      2：可以控制当前的标签设置样式。
      3：由于书写繁琐，并没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用。
   
   ```

3. 外部样式表

   ```html
   <head>
       <link rel="stylesheet" href="CSS文件路径">
   </head>
   引入外部样式表分为两步：:
      1： 新建一个后缀名为.css的样式文件，把所有CSS代码都放入此文件中。
      2：在HTML页面中，使用<link>标签引入这个文件。
   
   ```

   

| **样式表** | **优点**             | **缺点**     | **使用情况** | **控制范围** |
| ---------- | -------------------- | ------------ | ------------ | ------------ |
| 行内样式表 | 书写方便             | 结构样式混写 | 较少         | 控制一个标签 |
| 内部样式表 | 部分结构和样式分离   | 没有彻底分离 | 较多         | 控制一个页面 |
| 外部样式表 | 完全实现结构样式分离 | 需要引入     | 最多         | 控制多个页面 |

##### CSS基础选择器

根据不同的需求把不同的标签选出来

CSS使用font-family属性定义文本的字体系列。
CSS使用font-size属性定义字体大小。
CSS使用font-weight属性设置文本字体的粗细。
CSS使用color)属性设置文本的颜色。
CSS使用border、width、height属性设置标签的边框和宽高。
CSS使用background-color属性设置标签的背景色。

# 进阶第22天（JS）

是一门跨平台、面向对象的脚本语言，来控制网页的行为，它能使网页可交互，编程类语言

#### 引入方式

1. **内部脚本：**将JS代码定义在HTML页面中

   ```html
   <script>
   	alert("hello JS");
   </script>
   在HTML文档中可以在任意地方，放置任意数量的<script></script>
   一般把脚本置于<body>元素的底部，可改善显示速度，因为脚本执行会拖慢显示
   ```

2. **外部脚本：**将JS代码定义在外部JS文件中，然后引入到HTML页面中

   ```html
   <script src="JS路径"></script>
   外部脚本不能包含<script>标签
   <script>标签不能自闭和
   ```

#### JS语法

区分大小写

每行结尾的分号可有可无

注释：同Java

输出语句

```javascript
使用 window.alert() 写入警告框
使用 document.write() 写入 HTML 输出
使用 console.log() 写入浏览器控制台

```

##### 变量

使用var关键字来声明变量

```javascript
var test = 320;
test = "张三";
//JavaScript是一门弱类型语言，变量可以存放不同类型的值
//var定义的是全局变量
//let定义的是局部变量
//const定义的是常量（不变的量）
```

1. **命名规则：**
   - 组成字符可以是任何字母、数字、下划线或美元符号
   - 不能数字开头
2. ECMAScript 6 新增了 const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。 
3. ECMAScript 6 新增了 let 关键字来定义变量。它的用法类似于 var，但是所声明的变量，只在 let 关键字所在的代码块内有效，且不允许重复声明

##### 数据类型

- number：数字（整数、小数、NaN（不是一个数字））
- string：字符、字符串、单双引都可以
- boolean：布尔
- null：对象为空
- undefined：当声明的变量未初始化是，该变量的默认值是undefined
- typeof：可以获得数据类型

**特点：**

在JS中，五种原始数据类型**都可以作为判断条件使用**，

1. **string**：有内容则为true
2. **number**：不是零的数为true
3. **null**：false
4. **boolean**：
5. **undefined**：false

##### 运算符

- 一元运算符：++，--
- 算术运算符：+，-，*，/，%
- 赋值运算符：=，+=，-=…
- 关系运算符：>，<，>=，<=，!=，==，===…
- 逻辑运算符：&&，||，!
- 三元运算符：条件表达式 ? true_value : false_value 

==和===：**==会进行类型转换，===不会进行类型转换**

+和Java一样：遇到字符串是连接，如果字符串**是数值类型**的则可以进行**减乘除**操作（不是数字类型的则不可以）

##### 类型转换

- 其他类型转为数字：
  1. string将字符串字面值转为数字。如果字面值**不是数字**，**则转为NaN**。一般使用**parseInt**方法进行转换（能转的就都转，不能转的为NaN）
  2. boolean：true转为1，false转为0
- 其他类型转为boolean
  1. number：0和NaN转为false，其他true
  2. string：空字符串转为false，其他true
  3. null：转为false
  4. undefined：转为false

##### 流程控制语句

- if:
- switch:
- for:
- while:
- do…while:

##### 函数（方法）

是被设计为执行特定任务的代码块

通过**function**关键字进行定义

```
//方式1
function 函数名(参数1，参数2){
	代码块；
}
//方式2（匿名函数）不能单独使用，可以作为参数使用
var functionName = function (参数列表){
	要执行的代码
}
```

**注：**形式参数不需要类型。因为JavaScript是弱类型语言；返回值也不需要定义类型，可以在函数内部之间是用**return**返回

调用：JS中，**函数调用可以传递任意个数参数**

**调用：**函数名(实际参数列表)，只根据**函数名调用**，**不存在重载**（**直接覆盖上一个重名方法**，瀑布式加载）

```js
//html页面第一次加载会直接运行带括号的方法
pwd.onblur = checkPwd();//这样会直接运行方法
pwd.onblur = checkPwd;                                                        
      function checkPwd(){
          var length = pwd.value.length;
          if (length>0&&length<20){
              pwdErr.style.display="none";
              return true;
          }else{
              pwdErr.style.display=null;
              return false
          }
      }
```



##### JavaScript对象

###### Array

定义

```javascript
//方式1，未定义的元素值为undefined
var 变量名 = new Array(元素列表);
//方式2
var 变量名 = [元素列表];
```

访问：同Java（**数组名[索引] = 值**）

**注：JS数组类似于Java集合，长度，类型都可变**

###### Array属性

| 属性        | 描述                             |
| ----------- | -------------------------------- |
| constructor | 返回对创建此对象的数组函数的引用 |
| length      | 设置和返回数组中元素的数目       |
| prototype   | 使您有能力向对象添加属性和方法   |

###### Array对象方法

| 方法             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| concat()         | 连接两个或更多的数组，并返回结果                             |
| join()           | 把数组的所有元素放入一个字符串。元素通过制定的分割符进行分割 |
| pop()            | 删除并返回数组的最后一个元素                                 |
| push()           | 向数组的末尾添加一个或更多元素，并返回新的长度               |
| reverse()        | 颠倒数组中元素的顺序                                         |
| shift()          | 删除并返回数组的第一个元素                                   |
| sllce()          | 从某个已有的数组返回选定的元素                               |
| sort()           | 对数组的元素进行排序                                         |
| spllce()         | 删除元素，并向数组添加新元素                                 |
| toSource()       | 返回该对象的源代码                                           |
| toString()       | 把数组转换为字符串，并返回结果                               |
| toLocaleString() | 把数组转换为本地数组，并返回结果                             |
| unshift()        | 向数组的开头添加一个或更多元素，并返回新的长度               |
| valueOf()        | 返回数组对象的原始值                                         |

###### String

定义

```js
//方式1
var 变量名 = new String(s);
//方式2
var 变量名 = s;
```

属性：length：字符串的长度

方法：

​	charAt()：返回在指定位置的字符

​	indexOf()：检索字符串

​	其他同Java

###### 自定义对象

格式

```
var 对象名称 = {
	属性名称1:属性值1,
	属性名称2:属性值2,
	...
	函数名称:function(形参列表){},
	...
}
```

##### BOM

Browser Object Model 浏览器对象模型

JavaScript 将浏览器的各个组成部分封装为对象

组成：

###### Window：浏览器窗口对象

获取：直接使用window，其中window，可以省略

```javascript
window.alert("abc");
```

**属性**：获取其他BOM对象

- **history**
  - 对History对象的只读引用。请参数History对象。
- **Navigator**
  - 对Navigator对象的只读引用。请参数Navigator对象。
- **Screen**
  - 对Screen对象的只读引用。请参数Screen对像。
- **location**
  - 用于窗口或框架的Location对象。请参阅Location对象。

**方法**

- **alert()**

  - 显示带有一段消总和一个确认按钮的警告框。

- **confirm()**

  - 显示带有一段消总以及确认按钮和取消按钮的对话框。返回true和false

- **setInterval()**

  - 按照指定的周期（以毫秒计）来调用函数或计算表达式。多少毫秒后重复调用

  - ```
    setInterval(function(){方法体},毫秒值);
    ```

    

- **setTimeout()**

  - 在指定的毫秒数后调用函数或计算表达式。

  - ```js
    setTimeout(function(){方法体},毫秒值);
    ```

    

###### Navigator：浏览器对象

###### Screen：屏幕对象

###### History：历史记录对象

使用window.history获取，window.可以省略

获取：

```
window.history.方法();
history.方法();
```

方法：

- back()
  - 加载history列表中的前一个URL。后退
- forward()
  - 加载history列表中的下一个URL。前进

###### Location：地址栏对象

使用 window.location获取，其中window. 可以省略

获取

```
window.location.方法();
location.方法();
```

属性：

href：设置或返回完整的URL

##### DOM

Document Object Model 文档对象模型

将标记语言的各个组成部分封装为对象

JavaScript **通过 DOM**， 就能够对 **HTML进行操作了**：

1. 改变 HTML 元素的内容
2. 改变 HTML 元素的样式（CSS）
3. 对 HTML DOM 事件作出反应
4. 添加和删除 HTML 元素

###### Document：整个文档对象

###### Element：元素对象

**获取**：

使用Document对象的方法来获取

- getElementById：根据id属性值获取，返回一个Element对象

- getElementsByTagName：根据标签名称获取，返回Element对象数组

- getElementsByName：根据name属性值获取，返回Element对象数组

- getElementsByClassName：根据class属性值获取，返回Element对象数组

###### Attribute：属性对象

###### Text：文本对象

**innerHTML**方法可以修改标签内容

**元素对象名.style.样式名="值**"；

###### Comment：注释对象

##### 事件监听

事件：HTML事件是放生在HTML元素上的，如按钮被点击、鼠标移动到元素之上、按下键盘按键

JavaScript可以在事件被侦测到时执行代码

###### 事件绑定

```javascript
//方式一：通过HTML标签中的事件属性进行绑定
<input type="button" onclick='on()'>
function on(){
	alert("我被点击了")
}
//方式二：通过DOM元素属性绑定
<input type="button" id="but">
document.getElementById("but").onclick = function(){
	alert("我被点击了")
}
```



###### 常见事件

| **事件名**  | **说明**                 |
| ----------- | ------------------------ |
| onclick     | 鼠标单击事件             |
| onblur      | 元素失去焦点             |
| onfocus     | 元素获得焦点             |
| onload      | 某个页面或图像被完成加载 |
| onsubmit    | 当表单提交时触发该事件   |
| onkeydown   | 某个键盘的键被按下       |
| onmouseover | 鼠标被移到某元素之上     |
| onmouseout  | 鼠标从某元素移开         |

# 进阶第23天（Java Web）

HTTP-请求数据格式

```java
GET / HTTP/1.1 
Host: www.itcast.cn 
Connection: keep-alive 
User-Agent: Mozilla/5.0 Chrome/91.0.4472.106
…
POST / HTTP/1.1 //请求行
Host: www.itcast.cn //请求头
Connection: keep-alive 
Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 
User-Agent: Mozilla/5.0 Chrome/91.0.4472.106

username=superbaby&password=123456//请求体

```

##### 请求规则（格式）

**请求数据分为3部分：**

1. **请求行**：请求数据的第一行。其中GET表示请求方式， / 表示请求资源路径，HTTP/1.1表示协议版本
2. **请求头**：第二行开始，格式Key：Value形式
3. **请求体**：POST请求的最后一部分，存放请求参数

**GET请求和POST请求区别：**

1. GET请求**参数在请求行中**，没有请求体。POST请求参数**在请求体中**

2. **GET**请求**参数大小有限制**，POST没有

   

**常见的HTTP 请求头：**

- Host: 表示请求的主机名
- User-Agent: 浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0 ... Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...) like Gecko；
- Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；
- Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；
- Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。



**HTTP协议特点：**

**基于TCP协议：**面向连接，安全

基于请求-响应模型的：**一次请求对应一次响应**

HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求响应都是独立的。

**缺点：**多次请求间不能共享数据。

**优点**：速度快

##### 响应规则（格式）

**HTTP-响应数据格式**

```java
HTTP/1.1 200 OK//响应行（协议，状态码，状态码描述）
Server: Tengine//响应头
Content-Type: text/html
Transfer-Encoding: chunked…

<html>//响应体
<head>
     <title></title>
</head>
<body></body>
</html>

```

响应数据分为3部分：

1. 响应行：响应数据的第一行。其中HTTP/1.1表示协议版本，200表示响应状态码，OK表示状态码描述
2. 响应头：第二行开始，格式为key：value形式
3. 响应体： 最后一部分。存放响应数据

常见的HTTP 响应头：

- Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；
- Content-Length：表示该响应内容的长度（字节数）；
- Content-Encoding：表示该响应压缩算法，例如gzip；
- Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒
- Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；
- Content-Length：表示该响应内容的长度（字节数）；
- Content-Encoding：表示该响应压缩算法，例如gzip；
- Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒

| 状态码分类 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 1xx        | 响应中一—临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成测忽略它 |
| 2xx        | 成功一一表示请求已经被成功接收，处理已完诚                   |
| 3xx        | 重定向一一重定向到其它地方：它社客户端再发起一个请求以完成整个处理， |
| 4xx        | 客户端错误一—处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 |
| 5xx        | 服务器端错误-一处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTP版本不支持等 |

#### 创建Java Web项目

1. 先创建Maven项目，在pom.xml中坐标版本后面添加一个<packaging>war</packaging>刷新Maven
2. Ctrl+Shift+Alt+s打开Project Structure选择Facets双击红色目录添加webapp目录结构，再点击Deployment Description的加号添加web.xml文件一定要在webapp目录下
3. 打开Run =》Edit Configurations 点击加号选择TomcatServer =》Local =》Deployment的加号添加当前web项目

#### Servlet

Servlet是Java提供的一门Web资源开发技术

Servlet是JavaEE规范之一，就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet

###### Servlet是什么

1. Servlet是一个运行在web服务端的java小程序
2. 它可以用于接收和响应客户端的请求
3. 要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet
4. 每次清求都会执行service方法
5. Servleti还支持配置

##### Servlet实现步骤

1. 创建web项目，导入Servlet依赖坐标

   ```
   <dependency>    	<groupId>javax.servlet</groupId>    	<artifactId>javax.servlet-api</artifactId>    	<version>3.1.0</version>  				<scope>provided</scope>
   </dependency>
   ```

2. 创建：定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话

   ```
   public class ServletDemo1 implements Servlet {
       public void service(){}
   }
   ```

3. 配置：在类上使用@WebServlet注解，配置该Servlet的访问路径

   ```
   @WebServlet("/demo1")
   public class ServletDemo1 implements Servlet 
   ```

4. 访问：启动Tomcat，浏览器输入URL访问该Servlet

   ```
   http://localhost:8080/day09/demo1
   ```

##### Servlet执行流程

1. Servlet有web服务器创建
2. Servlet的方法由web服务器调用（我们自定义的Servlet，必须实现Servlet接口并重写方法，所以服务器指定我们的Servlet一定有方法）

##### Servlet生命周期

Servlet运行在Servlet容器(web服务器)中，其生命周期**由容器**来管理，分为4个阶段：

1. **加载和实例化**：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象
2. **初始化**：在Servlet实例化之后，容器将调用Servlet的**init()方**法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次
3. **请求处理**：**每次请求Servlet**时，Servlet容器都会调用Servlet的**service()**方法对请求进行处理。
4. **服务终止**：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的**destroy()方法完成资源的释放**。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收



```java
@WebServlet(urlPatterns = "/demo",loadOnStartup = 1)
//urlPatterns属性就是value属性：代表设置Servlet的虚拟路径
//负整数：第一次被访问时创建Servlet对象
//0或正整数：服务器启动时创建Servlet对象，数字越小优先级越高
```

Servlet方法：

```java
//初始化方法，在Servleti被创建时执行，只执行一次
void init(ServletConfig config)
//提供服务方法（请求），每次Servlet被访问，都会调用该方法
void service(ServletRequest req,ServletResponse res)
//销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet
void destroy()
//获取ServletConfig对象
ServletConfig getServletConfig(
//获取Servlet信息
String getServletlnfo()
```

##### Servlet体系结构

**HttpServlet**（对HTTP协议封装的Servlet实现类）==》**GenericServlet**（Servlet抽象实现类）==》**Servlet**（Servlet体系根接口）

我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会**继承HttpServlet**

###### 快捷构建HttpServlet的子类（Servlet）

包名右键 =》new =》Servlet =》改名字 =》将@WebServlet()中的name属性名删除只留下值

HTTP 协议中，GET 和 POST 请求方式的数据格式不一样，将来要想在Servlet中处理请求参数，得在service方法中判断请求方式，并且根据请求方式的不同，分别进行处理：

```java
//获取请求方式
String method req.getMethod();
//判断请求参数，不同请求方式，进行不一样的处理逻辑
if ("GET".equals(method)){
//执行GET请求方式的处理逻辑
doGet(req,resp);
Felse if("POST".equals(method)){
//执行P0ST请求方式的处理逻辑
doPost(req,resp);
```

##### Servlet urlPattern配置

Servlet想要被访问，必须配置其访问路径（urlPattern）

**一个Servlet，可以配置多个 urlPattern（虚拟路径）：**@WebServlet(urlPatterns = {"/demo1","/demo2"})

urlPattern **配置规则**

1. 精确匹配：@WebServlet("/user/select")

2. 目录匹配：@WebServlet("/user/*")

3. 扩展名匹配：@WebServlet("*.do")

4. 任意匹配：@WebServlet("/")或@WebServlet("/*")

5. **优先级：**

   ​    **精确路径 > 目录路径 > 扩展名路径 > /* > /**

   **/ 和 /* 区别：**

   - 当我们的项目中的Servlet配置了“/”，会覆盖掉tomcat中的DefaultServlet，当其他的 url-pattern都匹配不上时都会走这个Servlet

   - 当我们的项目中配置了“/*”，意味着匹配任意访问路径

##### XML配置方式编写Servlet

Servlet 从3.0版本后开始支持使用注解配置，3.0版本前只支持 XML 配置文件的配置方式

**步骤：**

1. 编写 Servlet类

2. 在 web.xml中配置该Servlet

   ```xml
   <!-- 同@WebServlet() -->
   <servlet>
   	<servlet-name>demo5</servlet-name>
   	<servlet-class>com.itheima.web.servlet.ServletDemo5</servlet-class>
   </servlet>
   <servlet-mapping>
   	<servlet-name>demo5</servlet-name>
   	<url-pattern>/demo5</url-pattern>
   </servlet-mapping>
   ```



# 查找1099端口的进程：netstat -ano | find "1099"

# 进阶24天

#### Request

web服务器收到客户端的http请求，会对每一次请求，分别创建一个用于代表**请求的request对象**和**代表响应的reponse对象**

 **封装了请求相关的信息，要得到浏览器信息，就找HttpServletRequest对象** 。

###### HttpServletRequest是什么

HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求中的所有信息都封装在这个对象中。

**用于**：

1. 防盗链;解析请求来源（**防止链接被其他网站盗用**）
2. **请求参数的获取**&各种表单输入项数据的获取;
3. 请求参数的中文乱码问题的解决；**post请求的参数乱码**

##### 使用Request对象的方法

###### 获取请求行

| 方法                                      | 返回值       | 描述                                                      |
| ----------------------------------------- | ------------ | --------------------------------------------------------- |
| <font color='red'>getMethod()</font>      | String       | 获取提交的方式 (GET,POST)                                 |
| getRequestURI()                           | String       | 获取请求的参数,请求服务器路径                             |
| getRequestURL()                           | StringBuffer | 获取请求的参数,请求服务器**完全路径**（**协议IP端口号**） |
| etQueryString()                           | String       | 获取请求行 问号后面的参数 (GET),?后面的所有参数           |
| <font color='red'>getContextPath()</font> | String       | 获取WEB应用名称                                           |
| getServletPath()                          | String       | 获取Servlet访问路径                                       |
| getRemoteAddr()                           | String       | 获取客户端主机ip                                          |

###### 获取请求头

```java
请求头数据格式键值对, k:v
指导性信息,指导服务器
```

| 方法                   | 返回值 | 描述                         |
| ---------------------- | ------ | ---------------------------- |
| getHeader(String name) | String | 获得一个key对应一个value的请 |

```java
//获取指定请求头
        String host = request.getHeader("Host");//服务器主机地址+端口号
        System.out.println("host："+host);
        String header = request.getHeader("User-Agent");
        System.out.println("浏览器的内核信息:"+header);
```



###### 获取请求参数（请求体）

| 方法                               | 返回值               | 描述                                                        |
| ---------------------------------- | -------------------- | ----------------------------------------------------------- |
| getParameter(表单中的name值)       | String               | 获得提交的参数（一个name对应一个value）                     |
| getParameterValues(表单中的name值) | String[]             | 获得提交的参数（一个name对应多个value）                     |
| getParameterMap()                  | Map<String,String[]> | 获得提交的参数，将提交的参数名称和对应值存入到一个Map集合中 |

```java
//Request对象获取请求参数；获得提交的参数（一个name对应一个value）
public String getParameter(表单中的name值): 
//获得提交的参数（一个name对应多个value）
public String[] getParameterValues(表单中的name值):
//获得提交的参数，将提交的参数名称和对应值存入到一个Map集合中
public Map<String,String[]> getParameterMap(): 
	
```

##### 请求参数解决中文乱码

- 当页面提交方式为GET：Tomcat8.0之后已经解决
- 当页面提交方式为POST：通过**request.setCharacterEncoding("UTF-8")**设置编码



#### Response

是把服务器请求的处理结果告知客户端。在B/S架构中，响应（Reponse）就是把结果带回浏览器、

###### HttpServletResponse是什么？

代表服务器的响应。可以完成向客户端发送数据、发送响应头、发送响应状态码

##### Response设置响应行

```
设置响应的状态码
- 200 正确
- 302 重定向
- 304 查找本地缓存
- 404 请求资源不存在
- 500 服务器内部错误
response.setStatus(500);
```



##### Response设置响应头

```
HTTP协议的响应头,数据格式键值对 k:v
包含指导性信息,指导客户端
```

| 方法              | 返回值 | 描述             |
| ----------------- | ------ | ---------------- |
| setStatus(int sc) | void   | 设置响应的状态码 |

| 方法                                                        | 返回值 | 描述                       |
| ----------------------------------------------------------- | ------ | -------------------------- |
| setDateHeader(String key,long l)                            | void   | 更改响应头，值为日期类型   |
| setIntHeader(String key,int value)                          | void   | 更改响应头，值为int类型    |
| <font color='red'>setHeader(String key,String value)</font> | void   | 更改响应头，值为String类型 |

**Response设置响应体**

  HTTP的响应体,就是页面的正文部分

###### 字符流向浏览器写数据

| Response中的方法 | 返回值      | 写数据方法 | 描述                                           |
| ---------------- | ----------- | ---------- | ---------------------------------------------- |
| **getWriter**()  | PrintWriter | write()    | 使用字符串数据,没有差别, 输出是整数,查询编码表 |
| **getWriter**()  | PrintWriter | print()    | 无论是什么,原样打印                            |

##### 字节流向浏览器写数据

| Response中的方法  | 返回值       | 写数据方法 | 描述                                             |
| ----------------- | ------------ | ---------- | ------------------------------------------------ |
| getOutputStream() | OutputStream | write()    | 返回字节输出流OutputStream，响应非文本类型的数据 |

##### 重定向

是通过各种方法将各种网络请求重写定个方法转到其他位置。在我们这里就是利用response对象，把浏览器地址重新定向到一个新的地址上（可以是内部资源也可以是外部资源）

可以使用**response.sendRedirect()**方法实现重定向操作

###### 特点

1. 是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化
2. 是由浏览器完成跳转，可以去访问任何的资源
3. 重定向至少两次请求。两次响应
4. 由响应对象告知浏览器的进行重新定向

​	

# 进阶第25天（JSP）

#### Reques域对象

是从客户端浏览器向服务器发送的一次请求信息的封装。

那么实质上向Request中所保存的数据有效期也是一次请求范围。

**当服务器做出响应后，请求对象就销毁了**，保存在其中的数据就无效了

##### Request域的范围

request只能在一次请求过程中传输数据。请求结束自动销毁

##### Request可以解决什么问题

- 解决处于同**一个请求多个处理模块之间的数据传输**问题
- 具体表现在通过request对象在实现转发时，把**数据通过request对象**带给**其它web**资源处理

##### Request域对象API

| 方法                                  | 返回值 | 描述                  |
| ------------------------------------- | ------ | --------------------- |
| setAttribute(String name, Object obj) | void   | 向Request域中保存数据 |
| getAttribute(String name)             | Object | 从Request域中获取数据 |
| removeAttribute(String name)          | void   | 从Request域中移除数据 |

#### 请求转发

一种在服务器内部的资源跳转方式

实现方式：**req.getRequestDiapatcher("资源B路径").forward(req.resp);**

请求转发资源间**共享数据**：使用Request对象

```java
void setAttribute(String name, Object o)：存储数据到 request域中

Object getAttribute(String name)：根据 key，获取值

void removeAttribute(String name)：根据 key，删除该键值对
```

请求转发**特点**：

- 浏览器地址栏路径不发生变化
- 只能转发到当前服务器的内部资源
- 一次请求，可以在转发的资源键使用request共享数据

##### 请求转发与重定向辨析

相同点：请求转发和重定向都可以解决，在Servlet程序中，一个Servlet需要调用另外的资源对浏览器进行响应

不同点：

1. 实际发生的位置不同，地址栏不同：
   - 转发是由**服务器**进行跳转，在转发的时候，浏览器的地址栏是没有发生变化的
   - 重定向是由**浏览器**进行跳转，进行重定向跳转的时候，浏览器的地址会发生变化
2. 能够访问的资源范围不一样
   - 转发是服务器跳转只能去往**当前web应用的资源**
   - 重定向是浏览器跳转，可以去**往任何的资源**
3. 传递数据的类型不同
   - 转发的request对象可以**传递各种类型的数据包括对象**
   - 重定向只能传递字符串。**两次请求**，不能再多个资源使用request共享数据。
4. 请求的次数不同
   - 转发是一次请求，一起响应
   - 重定向至少请求两次，响应两次

#### JSP

概念：Java Server Pages，Java服务端页面

一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容

JSP = HTML + Java

**JSP 本质上就是一个 Servlet**：**当JSP第一次**在被访问时，由JSP容器(Tomcat)将其**转换为 Java文件**(Servlet)，在由JSP容器(Tomcat)将其**编译**，**最终对外提供服务**的其实就是这**个字节码文件**

JSP的作用：简化开发，**避免了在Servlet中直接输出HTML标签**



##### 创建

1. 导入JSP坐标

   ```
   <dependency>  	
   	<groupId>javax.servlet.jsp</groupId>    	
   	<artifactId>jsp-api</artifactId>   	
   	<version>2.2</version>
   	<scope>provided</scope>
   </dependency>
   
   ```

2. 创建JSP文件

3. 编写HTML标签和Java代码

##### JSP脚本

分类：

- <%...%>：内容会直接放到_jspService()方法之中

- <%=…%>：内容会放到out.print()中（**直接在HTML页面输出**），作为out.print()的参数

- <%!…%>：内容会放到_jspService()方法之外（**成员变量位置**），被类直接包含

#### EL表达式

Expression Language 表达式语言，用于简化 JSP页面内的Java代码

**主要功能**：获取数据

**语法**：${request对象中存储的Key名}，获取域中存储的key为brands的数据

JavaWeb中的四大域对象：

1. page：当前页面有效
2. request：当前请求有效
3. session：当前会话有效
4. application：当前应用有效

#### JSTL标签

JSP标准标签库(Jsp Standarded Tag Library) ，**使用标签取代JSP页面上的Java代码**

##### 创建

1. 导入坐标

   ```xml
   <dependency>    
       <groupId>jstl</groupId>    
       <artifactId>jstl</artifactId>    
       <version>1.2</version>
   </dependency>
   <dependency>    
       <groupId>taglibs</groupId>    
       <artifactId>standard</artifactId>    
       <version>1.1.2</version>
   </dependency>
   ```

2. 在JSP页面上引入JSTL标签库

   ```
   <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
   ```

   

3. 使用

   1. ```html
      <c:if>相当于 if 判断
      属性：test，用于定义条件表达式
      <c:if test="${flag == 1}">
      男
      </c:if>
      <c:if test="${flag == 2}">
      女
      </c:if>
      
      ```

   2. ```html
      <c:forEach>：相当于 for 循环
      items：被遍历的容器
      var：遍历产生的临时变量
      varStatus：遍历状态对象
      
      
      <c:forEach items="${brands}" var="brand">    <tr align="center">
      <td>${brand.id}</td>        <td>${brand.brandName}</td>        <td>${brand.companyName}</td>        <td>${brand.description}</td>    
      </tr>
      </c:forEach>
      
      begin：开始数
      end：结束数
      step：步长
      <c:forEach begin="0" end="10" step="1" var="i">
      ${i}
      </c:forEach>
      
      
      ```

      

#### MVC模式

- M：Model，业务模型，处理业务
- V：View，视图，界面展示
- C：Controller，控制器，处理请求，调用模型和视图

#### 三层架构

- 表现层（包名：web/controller）：接收请求，封装数据，调用数据，调用业务逻辑层，响应数据
- 业务逻辑层（service）：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能
- 数据访问层（dao/mapper）：对数据库的CRUD基本操作



# 进阶第26天（Session）

#### 会话跟踪技术

会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应

会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据

HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享

##### 实现方式：

- 客户端会话跟踪技术：Cookie

- 服务端会话跟踪技术：Session

##### Cookie基本使用

客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问

1. 创建Cookie对象，设置数据

   ```java
   Cookie cookie = new Cookie("key","value");
   ```

2. 发送Cookie到客户端：使用response对象

   ```
   response.addCookie(cookie)
   ```

3. 获取客户端携带的所有Cookie，使用request对象

   ```
   Cookie[] cookies = request.getCookies()
   ```

4. 遍历数组，获取每一个Cookie对象：for

5. 使用Cookie对象方法获取数据

   ```
   cookie.getName()
   cookie.getValue()
   ```

##### Cookie原理

Cookie的实现是基于HTTP协议的

响应头：set-cookie

请求头：cookie

##### Cookie使用细节

Cookie 存活时间

- 默认情况下，Cookie 存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁

- setMaxAge(int seconds)：设置Cookie存活时间
  - 正数：将 Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除
  - 负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则 Cookie被销毁
  - 零：删除对应 Cookie

Cookie 存储中文

- Cookie 不能直接存储中文

- 如需要存储，则需要进行转码：URL编码

##### Session基本使用

服务端会话跟踪技术：将数据保存到服务端

JavaEE 提供 HttpSession接口，来实现一次会话的多次请求间数据共享功能

使用：

1. 获取Session对象

   ```
   HttpSession session = request.getSession()
   ```

   

2. Session对象功能：

   1. void setAttribute(String name, Object o)：存储数据到 session 域中
   2. Object getAttribute(String name)：根据 key，获取值
   3. void removeAttribute(String name)：根据 key，删除该键值对

##### Session原理

Session是基于Cookie实现的

```
HttpSession session = req.getSession();
```

##### Session使用细节

Session 钝化、活化：

- 服务器重启后，Session中的数据是否还在？
  - 钝化：在服务器正常关闭后， Tomcat会自动将 Session数据写入硬盘的文件中
  - 活化：再次启动服务器后，从文件中加载数据到Session中

- Seesion 销毁：

  - 默认情况下，无操作，30分钟自动销毁

    ```xml
    <session-config>
    <session-timeout>30</session-timeout>
    </session-config>
    ```

    

  - 调用 Session对象的 invalidate()方法

##### Cookie和Session区别

Cookie 和 Session 都是来完成一次会话内多次请求间数据共享的

区别：

- 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端
- 安全性：Cookie 不安全，Session 安全
- 数据大小：Cookie 最大3KB，Session 无大小限制
- 存储时间：Cookie 可以长期存储，Session 默认30分钟
- 服务器性能：Cookie 不占服务器资源，Session 占用服务器资源
