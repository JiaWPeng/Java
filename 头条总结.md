# 1. 使用的技术点

## 1.1 加密

分为可逆加密和不逆可加密

1. 可逆加密：
   - 对称加密：【**文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥**】
     - **常见的对称加密算：**AES、DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、HS256
     - **用途：** 一般用于保存用户手机号、身份证等敏感但能解密的信息。
     - **优点:**  对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。
     - **缺点:**  没有非对称加密安全.
     - ![image-20221231212714300](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2022/12/31_21_27_14_image-20221231212714300.png)
   - 非对称加密：公钥加密，私钥解密；私钥加密，公钥解密。
     - **常见的对称加密算：**RSA、DSA（数字签名用）、ECC（移动设备用）、RS256 (采用SHA-256 的 RSA 签名)
     - **用途：** 一般用于签名和认证。私钥服务器保存, 用来加密,  公钥客户拿着用于对于令牌或者签名的解密或者校验使用.
     - **优点: ** 非对称加密与对称加密相比，其安全性更好；
     - **缺点:**  非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
     - **签名：**私钥签名,  持有公钥进行验证是否被篡改过.
     - ![image-20221231212659070](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2022/12/31_21_27_6_image-20221231212659070.png)
2. 不可逆加密：一旦加密就不能反向解密得到密码原文
   - **种类：**Hash加密算法, 散列算法, 摘要算法等
   - **用途：**一般用于效验下载文件正确性，一般在网站上下载文件都能见到；存储用户敏感信息，如密码、 卡号等不可解密的信息
   - **常见的不可逆加密算法有：** `MD5、SHA、HMAC、BCrypt`

### 1.1.1 Token验证（JWT令牌）

使用Base64编码

Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一。Base64编码可用于在HTTP环境下传递较长的标识信息。采用Base64Base64编码解码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。**注意：Base64只是一种编码方式，不算加密方法。**

我们现在了解了基于token认证的交互机制，但令牌里面究竟是什么内容？什么格式呢？市面上基于token的认证方式大都采用的是JWT(Json Web Token)。

​	JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。

**JWT令牌结构：**

JWT令牌由Header、Payload、Signature三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz

base64UrlEncode(header)：jwt令牌的第一部分。base64UrlEncode(payload)：jwt令牌的第二部分。
secret：签名所使用的密钥。

分为三部分：

1. Header（头部）：包括令牌的类型（即JWT）及使用的哈希算法（如HMAC、SHA256或RSA）

   - 例如：

     ```
     {
     "alg": "HS256",
     "typ": "JWT"
     }
     JWT令牌的第一部分
     ```

2. Payload（负载）：内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比如：iss（签发者），exp（过期时间戳）， sub（面向的用户）等，也可自定义字段。

   此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。

   - 例如：

     ```
     {
     "sub": "1234567890",
     "name": "456",
     "admin": true
     }
     JWT令牌的第而部分
     ```

3. Signature（签名）此部分用于防止jwt内容被篡改。这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。

   - 例如

   - ```
     HMACSHA256(base64UrlEncode(header) + "." +base64UrlEncode(payload)，secret)
     JWT令牌的第三部分
     ```

#### 实现

需要引入jwt相关依赖

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
</dependency>
```



新建单元测试

``````java
/**
 * jwt生成与解析介绍
 */
public class JWTTest {


    /**
     * 生成JWT（一般在登录成功后将生成的JWT当做TOKEN来使用）
      */
    @Test
    public void testCreateJwt(){
        //eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjZTAyNzQ5NC1hZjc4LTQ1MTMtODY2Ni0xYjQxMTNiZjc4ZWQiLCJzdWIiOiJhbGwiLCJ1c2VybmFtZSI6InpoYW5nc2FuIiwidXNlcklkIjoxMjMsImlhdCI6MTYxNDE0OTg3NSwiZXhwIjoxNjE0MTUzNDc1fQ.AxKYDz5vHg_EnGxm8Z9zH6oDpSKQZBjDiiEsNt_aec8
        String secret = "itcast"; //对称加密密钥
        String token = Jwts.builder()、
            	.signWith(SignatureAlgorithm.HS256, secret)// 加密方式和加密的Key 防止恶意篡改数据
                .setId(UUID.randomUUID().toString()) //jwt的唯一标识 
                .setSubject("all")
                .claim("username", "zhangsan")
                .claim("userId",123)
                .setIssuedAt(new Date())//创建时间
                .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000)) //1小时过期
                .compact();
        System.out.println(token);
    }

    /**
     * 解析JWT（一般登陆后访问系统时需要携带TOKEN字符串，系统会使用JWT工具类校验TOKEN字符串）
     */
    @Test
    public void testParseJwt(){
        String secret = "itcast"; //对称加密密钥
        String token = "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjZTAyNzQ5NC1hZjc4LTQ1MTMtODY2Ni0xYjQxMTNiZjc4ZWQiLCJzdWIiOiJhbGwiLCJ1c2VybmFtZSI6InpoYW5nc2FuIiwidXNlcklkIjoxMjMsImlhdCI6MTYxNDE0OTg3NSwiZXhwIjoxNjE0MTUzNDc1fQ.AxKYDz5vHg_EnGxm8Z9zH6oDpSKQZBjDiiEsNt_aec8";
        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
        System.out.println("头：" + claimsJws.getHeader());
        System.out.println("载荷："   +  claimsJws.getBody());
        System.out.println("userId：" +  claimsJws.getBody().get("userId"));
        System.out.println("签名：" + claimsJws.getSignature());
    }

}
``````



### 1.1.2 Bcrypt加密

在用户模块，对于用户密码的保护，通常都会进行加密。我们通常对密码进行加密，然后存放在数据库中，在用户进行登录的时候，将其输入的密码进行加密然后与数据库中存放的密文进行比较，以验证用户密码是否正确。  目前，MD5和BCrypt比较流行。相对来说，BCrypt比MD5更安全。

BCrypt 官网[http://www.mindrot.org/projects/jBCrypt/](http://www.mindrot.org/projects/jBCrypt/)

（1）我们从官网下载源码

（2）新建工程，将源码类BCrypt拷贝到工程

（3）新建测试类，main方法中编写代码，实现对密码的加密

（4）新建单元测试编写代码，实现对密码的校验。BCrypt不支持反运算，只支持密码校验。

```java
/**
 * 加密方式测试
 */
public class EncryptTest {

   /**
     * 测试bcrypt加密（常用于用户注册或新增用户对密码进行密码）
     */
    @Test
    public void testBCryptForRegister(){
        for (int i = 0; i < 10; i++) {
            String pwd = "123456";
            String salt =  BCrypt.gensalt();
            String pwdEncrypt = BCrypt.hashpw(pwd,salt);
            System.out.println("盐："+salt+"，加密后： " +pwdEncrypt);
        }
    }


    /**
     * 测试BCrypt校验（常用于用户登录时判断密码是否正确）
     */
    @Test
    public void testBCryptForLogin(){
        String pwd = "123456";
        String pwdDB = "$2a$10$owzLG4fiZ4vmUSnmubaY9.FGcTuCDsRqvKNn3wiuYhQnyXNgO.96i";

        boolean result = BCrypt.checkpw(pwd, pwdDB);
        if(result){
            System.out.println("登录成功");
        } else {
            System.out.println("密码错误登录失败");
        }
    }
}
```

#### MD5加盐和BCrypt的区别

MD5加盐（随机盐）需要记录加盐的值，而BCrypt不需要记录，节省数据库空间

Bcrypt生成的密文是60位的。而MD5的是32位的。

BCrypt比MD5更安全，但是加密更慢

## 1.2 swagger加knife4j（APIPost APIFox）

Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<https://swagger.io/>)。 它的主要作用是：

1. 使得前后端分离开发更加方便，有利于团队协作

2. 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担

3. 功能测试 

   Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。

SpringBoot集成Swagger

- 引入依赖,在heima-leadnews-model和heima-leadnews-common模块中引入该依赖

  ```xml
  <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger2</artifactId>
  </dependency>
  <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger-ui</artifactId>
  </dependency>
  ```

只需要在heima-leadnews-common中进行配置即可，因为其他微服务工程都直接或间接依赖即可。

- 在heima-leadnews-common工程中添加一个配置类

新增：com.heima.common.swagger.Swagger2Configuration

```java
package com.heima.common.swagger;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class Swagger2Configuration {

   @Bean
   public Docket buildDocket() {
      return new Docket(DocumentationType.SWAGGER_2)
              .apiInfo(buildApiInfo())
              .select()
              // 要扫描的API(Controller)基础包
              .apis(RequestHandlerSelectors.basePackage("com.heima"))
              .paths(PathSelectors.any())
              .build();
   }

   private ApiInfo buildApiInfo() {
      Contact contact = new Contact("黑马程序员","","");
      return new ApiInfoBuilder()
              .title("黑马头条-平台管理API文档")
              .description("黑马头条后台api")
              .contact(contact)
              .version("1.0.0").build();
   }
}
```

联调

在heima-leadnews-common模块中的resources目录中新增以下目录和文件

文件：resources/META-INF/Spring.factories

```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.heima.common.swagger.Swagger2Configuration
```

（3）Swagger常用注解

在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：

@Api：修饰整个类，描述Controller的作用  

@ApiOperation：描述一个类的一个方法，或者说一个接口  

@ApiParam：单个参数的描述信息  

@ApiModel：用对象来接收参数  

@ApiModelProperty：用对象接收参数时，描述对象的一个字段  

@ApiResponse：HTTP响应其中1个描述  

@ApiResponses：HTTP响应整体描述  

@ApiIgnore：使用该注解忽略这个API  

@ApiError ：发生错误返回的信息  

@ApiImplicitParam：一个请求参数  

@ApiImplicitParams：多个请求参数的描述信息



 @ApiImplicitParam属性：

| 属性         | 取值   | 作用                                          |
| ------------ | ------ | --------------------------------------------- |
| paramType    |        | 查询参数类型                                  |
|              | path   | 以地址的形式提交数据                          |
|              | query  | 直接跟参数完成自动映射赋值                    |
|              | body   | 以流的形式提交 仅支持POST                     |
|              | header | 参数在request headers 里边提交                |
|              | form   | 以form表单的形式提交 仅支持POST               |
| dataType     |        | 参数的数据类型 只作为标志说明，并没有实际验证 |
|              | Long   |                                               |
|              | String |                                               |
| name         |        | 接收参数名                                    |
| value        |        | 接收参数的意义描述                            |
| required     |        | 参数是否必填                                  |
|              | true   | 必填                                          |
|              | false  | 非必填                                        |
| defaultValue |        | 默认值                                        |

我们在ApUserLoginController中添加Swagger注解，代码如下所示：

```java
@RestController
@RequestMapping("/api/v1/login")
@Api(value = "app端用户登录", tags = "ap_user", description = "app端用户登录API")
public class ApUserLoginController {

    @Autowired
    private ApUserService apUserService;

    @PostMapping("/login_auth")
    @ApiOperation("用户登录")
    public ResponseResult login(@RequestBody LoginDto dto){
        return apUserService.login(dto);
    }
}
```

LoginDto

```java
@Data
public class LoginDto {

    /**
     * 手机号
     */
    @ApiModelProperty(value="手机号",required = true)
    private String phone;

    /**
     * 密码
     */
    @ApiModelProperty(value="密码",required = true)
    private String password;
}
```

### knife4j

以下部分熟悉即可，无需手动再次配置，基础工程中已经配置好了。

(1)简介

knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!

gitee地址：https://gitee.com/xiaoym/knife4j

官方文档：https://doc.xiaominfo.com/

效果演示：http://knife4j.xiaominfo.com/doc.html

(2)核心功能

该UI增强包主要包括两大核心功能：文档说明 和 在线调试

- 文档说明：根据Swagger的规范说明，详细列出接口文档的说明，包括接口地址、类型、请求示例、请求参数、响应示例、响应参数、响应码等信息，使用swagger-bootstrap-ui能根据该文档说明，对该接口的使用情况一目了然。
- 在线调试：提供在线接口联调的强大功能，自动解析当前接口参数,同时包含表单验证，调用参数可返回接口响应内容、headers、Curl请求命令实例、响应时间、响应状态码等信息，帮助开发者在线调试，而不必通过其他测试工具测试接口是否正确,简介、强大。
- 个性化配置：通过个性化ui配置项，可自定义UI的相关显示信息
- 离线文档：根据标准规范，生成的在线markdown离线文档，开发者可以进行拷贝生成markdown接口文档，通过其他第三方markdown转换工具转换成html或pdf，这样也可以放弃swagger2markdown组件
- 接口排序：自1.8.5后，ui支持了接口排序功能，例如一个注册功能主要包含了多个步骤,可以根据swagger-bootstrap-ui提供的接口排序规则实现接口的排序，step化接口操作，方便其他开发者进行接口对接

(3)快速集成

- 在heima-leadnews-common模块中的`pom.xml`文件中引入`knife4j`的依赖,如下：

```xml
<dependency>
     <groupId>com.github.xiaoymin</groupId>
     <artifactId>knife4j-spring-boot-starter</artifactId>
</dependency>
```

- 创建Swagger配置文件

在heima-leadnews-common的Swagger2Configuration中补上

![image-20221231214223188](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2022/12/31_21_42_23_image-20221231214223188.png)

以上有两个注解需要特别说明，如下表：

| 注解              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| `@EnableSwagger2` | 该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加 |
| `@EnableKnife4j`  | 该注解是`knife4j`提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加 |

- 访问

在浏览器输入地址：`http://ip:port/doc.html`

## 1.3 gateway网关

**虚拟网卡就是本地（localhost），nginx在虚拟机（192.168.200.130）通过虚拟网卡绑定在本地电脑上 所以直接访问150就可以访问到服务**

**130是虚拟机ip  150对于虚拟机是电脑ip**

## 1.4 FreeMaker模板引擎

​	FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。

![image-20221231214917986](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2022/12/31_21_49_18_image-20221231214917986.png)

常用的java模板引擎还有哪些？

Jsp、Freemarker、Thymeleaf 、Velocity 等。

1.Jsp 为 Servlet 专用，不能单独进行使用。

2.Thymeleaf 为新技术，功能较为强大，但是执行的效率比较低。

3.Velocity从2010年更新完 2.0 版本后，便没有在更新。Spring Boot 官方在 1.4 版本后对此也不在支持，虽然 Velocity 在 2017 年版本得到迭代，但为时已晚。 

##### 使用

1 freemarker依赖包说明

```yaml
<dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-freemarker</artifactId>
    </dependency>
```



2  freemarker配置application.yml说明

```yaml
 port: 8881 #服务端口
spring:
  application:
    name: freemarker-demo #指定服务名
  freemarker:
    cache: false  #关闭模板缓存，方便测试
    settings:
      template_update_delay: 0 #检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试
    suffix: .ftl               #指定Freemarker模板文件的后缀名
    template-loader-path: classpath:/templates   #模板存放位置n;
```



3 在resources templates   01-basic.ftl 内容如下

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hello World!</title>
</head>
<body>
<b>普通文本 String 展示：</b><br><br>
Hello ${name} <br>
<hr>
<b>对象Student中的数据展示：</b><br/>
姓名：${stu.name}<br/>
年龄：${stu.age}
<hr>
</body>
</html>
```

4 快速测试体验

启动freemarker-demo 工程中 FreemarkerDemoApplication类

请求：http://localhost:8881/basic

![image-20221231215110126](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2022/12/31_21_51_10_image-20221231215110126.png)

### freemarker语法总结

#### 基础语法种类

  1、注释，即<#--  -->，介于其之间的内容会被freemarker忽略

```velocity
<#--我是一个freemarker注释-->
```

  2、插值（Interpolation）：即 **`${..}`** 部分,freemarker会用真实的值代替**`${..}`**

```velocity
Hello ${name}
```

  3、FTL指令：和HTML标记类似，名字前加#予以区分，Freemarker会解析标签中的表达式或逻辑。

```velocity
<# >FTL指令</#> 
```

  4、文本，仅文本信息，这些不是freemarker的注释、插值、FTL指令的内容会被freemarker忽略解析，直接输出内容。

```velocity
<#--freemarker中的普通文本-->
我是一个普通的文本
```

#### 集合指令（List和Map）

数据模型：

在HelloController中新增如下方法：

```java
@GetMapping("/list")
public String list(Model model){

    //------------------------------------
    Student stu1 = new Student();
    stu1.setName("小强");
    stu1.setAge(18);
    stu1.setMoney(1000.86f);
    stu1.setBirthday(new Date());

    //小红对象模型数据
    Student stu2 = new Student();
    stu2.setName("小红");
    stu2.setMoney(200.1f);
    stu2.setAge(19);

    //将两个对象模型数据存放到List集合中
    List<Student> stus = new ArrayList<>();
    stus.add(stu1);
    stus.add(stu2);

    //向model中存放List集合数据
    model.addAttribute("stus",stus);

    //------------------------------------

    //创建Map数据
    HashMap<String,Student> stuMap = new HashMap<>();
    stuMap.put("stu1",stu1);
    stuMap.put("stu2",stu2);
    // 3.1 向model中存放Map数据
    model.addAttribute("stuMap", stuMap);

    return "02-list";
}
```

2、模板：

在templates中新增`02-list.ftl`文件

实例代码：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hello World!</title>
</head>
<body>
    
<#-- list 数据的展示 -->
<b>展示list中的stu数据:</b>
<br>
<br>
<table>
    <tr>
        <td>序号</td>
        <td>姓名</td>
        <td>年龄</td>
        <td>钱包</td>
    </tr>
    <#list stus as stu>
        <tr>
            <td>${stu_index+1}</td>
            <td>${stu.name}</td>
            <td>${stu.age}</td>
            <td>${stu.money}</td>
        </tr>
    </#list>

</table>
<hr>
    
<#-- Map 数据的展示 -->
<b>map数据的展示：</b>
<br/><br/>
<a href="###">方式一：通过map['keyname'].property</a><br/>
输出stu1的学生信息：<br/>
姓名：${stuMap['stu1'].name}<br/>
年龄：${stuMap['stu1'].age}<br/>
<br/>
<a href="###">方式二：通过map.keyname.property</a><br/>
输出stu2的学生信息：<br/>
姓名：${stuMap.stu2.name}<br/>
年龄：${stuMap.stu2.age}<br/>

<br/>
<a href="###">遍历map中两个学生信息：</a><br/>
<table>
    <tr>
        <td>序号</td>
        <td>姓名</td>
        <td>年龄</td>
        <td>钱包</td>
    </tr>
    <#list stuMap?keys as key >
        <tr>
            <td>${key_index}</td>
            <td>${stuMap[key].name}</td>
            <td>${stuMap[key].age}</td>
            <td>${stuMap[key].money}</td>
        </tr>
    </#list>
</table>
<hr>
 
</body>
</html>
```

👆上面代码解释：

${k_index}：
	index：得到循环的下标，使用方法是在stu后边加"_index"，它的值是从0开始

#### if指令

​	 if 指令即判断指令，是常用的FTL指令，freemarker在解析时遇到if会进行判断，条件为真则输出if中间的内容，否则跳过内容不再输出。

- 指令格式

```html
<#if ></if>

<#list stus as stu >
        <#if stu.name='小红'>
            <tr style="color: red">
                <td>${stu_index}</td>
                <td>${stu.name}</td>
                <td>${stu.age}</td>
                <td>${stu.money}</td>
            </tr>
            <#else >
            <tr>
                <td>${stu_index}</td>
                <td>${stu.name}</td>
                <td>${stu.age}</td>
                <td>${stu.money}</td>
            </tr>
        </#if>
    </#list>
```

#### 运算符

**1、算数运算符**

FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:

- 加法： `+`
- 减法： `-`
- 乘法： `*`
- 除法： `/`
- 求模 (求余)： `%`



模板代码

```html
<b>算数运算符</b>
<br/><br/>
    100+5 运算：  ${100 + 5 }<br/>
    100 - 5 * 5运算：${100 - 5 * 5}<br/>
    5 / 2运算：${5 / 2}<br/>
    12 % 10运算：${12 % 10}<br/>
<hr>
```

除了 + 运算以外，其他的运算只能和 number 数字类型的计算。







**2、比较运算符**

- **`=`**或者**`==`**:判断两个值是否相等. 
- **`!=`**:判断两个值是否不等. 
- **`>`**或者**`gt`**:判断左边值是否大于右边值 
- **`>=`**或者**`gte`**:判断左边值是否大于等于右边值 
- **`<`**或者**`lt`**:判断左边值是否小于右边值 
- **`<=`**或者**`lte`**:判断左边值是否小于等于右边值 



= 和 == 模板代码

```
<body>

    <b>比较运算符</b>
    <br/>
    <br/>

    <dl>
        <dt> =/== 和 != 比较：</dt>
        <dd>
            <#if "xiaoming" == "xiaoming">
                字符串的比较 "xiaoming" == "xiaoming"
            </#if>
        </dd>
        <dd>
            <#if 10 != 100>
                数值的比较 10 != 100
            </#if>
        </dd>
    </dl>



    <dl>
        <dt>其他比较</dt>
        <dd>
            <#if 10 gt 5 >
                形式一：使用特殊字符比较数值 10 gt 5
            </#if>
        </dd>
        <dd>
            <#-- 日期的比较需要通过?date将属性转为data类型才能进行比较 -->
            <#if (date1?date >= date2?date)>
                形式二：使用括号形式比较时间 date1?date >= date2?date
            </#if>
        </dd>
    </dl>

    <br/>
<hr>
</body>
```

Controller 的 数据模型代码

```java
@GetMapping("operation")
public String testOperation(Model model) {
    //构建 Date 数据
    Date now = new Date();
    model.addAttribute("date1", now);
    model.addAttribute("date2", now);
    
    return "03-operation";
}
```

**比较运算符注意**

- **`=`**和**`!=`**可以用于字符串、数值和日期来比较是否相等
- **`=`**和**`!=`**两边必须是相同类型的值,否则会产生错误
- 字符串 **`"x"`** 、**`"x "`** 、**`"X"`**比较是不等的.因为FreeMarker是精确比较
- 其它的运行符可以作用于数字和日期,但不能作用于字符串
- 使用**`gt`**等字母运算符代替**`>`**会有更好的效果,因为 FreeMarker会把**`>`**解释成FTL标签的结束字符
- 可以使用括号来避免这种情况,如:**`<#if (x>y)>`**



3、逻辑运算符**

- 逻辑与:&& 
- 逻辑或:|| 
- 逻辑非:! 

逻辑运算符只能作用于布尔值,否则将产生错误 。



#### 空值处理

**1、判断某变量是否存在使用 “??”**

用法为:variable??,如果该变量存在,返回true,否则返回false 

例：为防止stus为空报错可以加上判断如下：

```velocity
    <#if stus??>
    <#list stus as stu>
    	......
    </#list>
    </#if>
```



**2、缺失变量默认值使用 “!”**

- 使用!要以指定一个默认值，当变量为空时显示默认值

  例：  ${name!''}表示如果name为空显示空字符串。



- 如果是嵌套对象则建议使用（）括起来

  例： ${(stu.bestFriend.name)!''}表示，如果stu或bestFriend或name为空默认显示空字符串。

#### 内建函数

内建函数语法格式： **`变量+?+函数名称`**  

**1、和到某个集合的大小**

**`${集合名?size}`**



**2、日期格式化**

显示年月日: **`${today?date}`** 
显示时分秒：**`${today?time}`**   
显示日期+时间：**`${today?datetime}`**   
自定义格式化：  **`${today?string("yyyy年MM月")}`**



**3、内建函数`c`**

model.addAttribute("point", 102920122);

point是数字型，使用${point}会显示这个数字的值，每三位使用逗号分隔。

如果不想显示为每三位分隔的数字，可以使用c函数将数字型转成字符串输出

**`${point?c}`**

**4、将json字符串转成对象**

一个例子：

其中用到了 assign标签，assign的作用是定义一个变量。

```velocity
<#assign text="{'bank':'工商银行','account':'10101920201920212'}" />
<#assign data=text?eval />
开户行：${data.bank}  账号：${data.account}
```

### 使用

导入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-freemarker</artifactId>
</dependency>
```

修改配置

```yaml
spring
  freemarker:
    cache: false  #关闭模板缓存，方便测试
    settings:
      template_update_delay: 0 #检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试
    suffix: .ftl               #指定Freemarker模板文件的后缀名
    template-loader-path: classpath:/templates
    
# freemarker模板文件通常都是以ftl作为扩展名,也可以为html、xml、jsp等

```

使用import freemarker.template.Configuration;来获取模板

合成
        //第一个参数 数据模型
        //第二个参数  输出流
        template.process(params, new FileWriter("d:/list.html"));



## 1.5MinIO对象存储服务

是一个分布式文件存储技术

#### 使用原因：

将静态文件放在专用的服务器上，这样可以提高运行服务器的带宽，性能

##### 关键字：

1. Bubcket：根目录
2. Obeject：对象文件
3. Keys：文件名
4. AccessKey：登录账号
5. SecretKey：登录密码

#### 使用方法：

添加依赖

```xml
        <dependency>
            <groupId>com.heima</groupId>
            <artifactId>heima-file-starter</artifactId>
            <version>1.0-SNAPSHOT</version>
         </dependency>
  
```

修改配置

```yaml
minio:
  accessKey: minio
  secretKey: minio123
  bucket: leadnews
  endpoint: http://192.168.200.130:9000
  readPath: http://192.168.200.130:9000
```

创建方法，将文件上传到minio服务器

```java
    /**
     *  上传html文件
     * @param prefix  文件前缀
     * @param filename   文件名
     * @param inputStream  文件流
     * @return  文件全路径
     */
    @Override
    public String uploadHtmlFile(String prefix, String filename,InputStream inputStream) {
        String filePath = builderFilePath(prefix, filename);
        try {
            PutObjectArgs putObjectArgs = PutObjectArgs.builder()
                    .object(filePath)
                    .contentType("text/html")
                    .bucket(minIOConfigProperties.getBucket()).stream(inputStream,inputStream.available(),-1)
                    .build();
            minioClient.putObject(putObjectArgs);
            StringBuilder urlPath = new StringBuilder(minIOConfigProperties.getReadPath());
            urlPath.append(separator+minIOConfigProperties.getBucket());
            urlPath.append(separator);
            urlPath.append(filePath);
            return urlPath.toString();
        }catch (Exception ex){
            log.error("minio put file error.",ex);
            ex.printStackTrace();
            throw new RuntimeException("上传文件失败");
        }
    }
```

如果上传出现一下异常：

``````
io.minio.errors.ErrorResponseException: The difference between the request time and the server's time is too large.
``````

那么解决办法就是，在服务器上执行命令：

``````
ntpdate cn.pool.ntp.org
``````

单独执行如上命令，只能临时解决时间同步，如果希望每次开启虚拟机都同步时间，需要将执行如下操作：

1. 编辑   vim /etc/rc.local，将命令ntpdate cn.pool.ntp.org添加到最后一行

   ``````shell
   vim /etc/rc.local
   ``````

   ![image-20221231220624619](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2022/12/31_22_6_24_image-20221231220624619.png)

2. 给rc.local添加执行权限

   ``````shell
   chmod +x /etc/rc.d/rc.local
   ``````

3. 执行命令reboot重启系统，发现时间开机后能立即同步了





# 自媒体管理端

## 使用的技术栈

线程池

OCR图片识别技术 Tess4j

DFA算法

第三方内容审核百度云和阿里云

微服务远程调用 Feign

分布式对象文件存储服务 MinIO

模板文件生成 FreeMarker

## 1)文章状态查看

### 需求：获取用户ID

1. 在gateway网关中解析token的负载并提取出来用户id
2. 自定义ThreadLocal工具类设置用户id
3. 使用用户id时，只需要使用ThreadLocal工具类获取用户id

### 需求：获取当前用户下发布的所有文章

1. 根据查询条件设置SQL查询语句即可

### 

## 2)素材上传

### 需求：上传图片

1. 使用MinIO来存储文件

   1. **为什么使用MinIO**：减轻服务器压力、资源占用、提高服务器性能
   2. **使用方式：**查看App端文章查看的对象存储服务MinIO

2. 判断用户的上传文件的类型

   1. 使用Hutools工具类中的FileTypeUtil：

   2. ```
      如果FileTypeUtil中没有文件的类型，就会以文件名的后缀来获取格式
      所以将文件名的后缀去掉
      ```

## 3)文章发布



实现思路分析

![image-20230104123011092](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2023/01/5_9_32_46_4_12_30_11_image-20230104123011092.png)

### 需求：判断是否有主图

1. 封面自动匹配规则：
   1. 内容中无图->封面无图
   2. 内容中图片数量大于等于1小于3时>选第一张做封面
   3. 内容中图片数量大于等于3->选前三张做封面
2. 根据提交状态来判断是否是草稿
3. 保存文章的各个关系到表中

## 4)文章审核

![image-20230104123610917](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2023/01/4_12_36_11_image-20230104123610917.png)

### 需求：文本违规，图片违规，图片内容违规

![image-20230104123706881](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2023/01/4_12_37_6_image-20230104123706881.png)

![image-20230104130359284](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2023/01/4_13_3_59_image-20230104130359284.png)

1. 首先使用DFA算法过滤敏感词汇（不收费）

   1. **实现方法**：查看leadnews-uilts下的SensitiveWordUtil类

2. 使用开源工具Tess4j识别图中文字

   1. 获取文章中的所有图片并去重

   2. 使用Tess4j识别图中文字

      1. **使用方法**：

         ```java
         		StringBuffer content = new StringBuffer();
                 List<byte[]> imageToByteList = getImageToByteList(wmNews, contentImageList);
                 for (byte[] bytes : imageToByteList) {
                     try {
                         ByteArrayInputStream in = new ByteArrayInputStream(bytes);
                         BufferedImage read = ImageIO.read(in);
                         String ocr = tess4jClient.doOCR(read);
                         log.info("OCR图片识别结果：{}", ocr);
                         if (ocr != null) {
                             content.append(ocr);
                         }
                     } catch (IOException e) {
                         e.printStackTrace();
                     } catch (TesseractException e) {
                         e.printStackTrace();
                     }
                 }
         ```

3. 使用阿里云接口实现（收费）

   1. 使用方法：查看leadnews-basic下的audit-starter模块或者查看阿里云内容安全官方文档  [阿里云内容审核文档](https://help.aliyun.com/document_detail/92546.html)

### 需求：当分表时，文章id重复解决方法

**分布式id - 使用雪花算法**

snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0

![image-20230103104201600](https://gitlab.com/JWPeng/image/-/raw/main/pictures/2023/01/5_9_32_46_4_12_38_24_3_10_42_8_image-20230103104201600.png)

**为什么使用雪花算法**

在数据库分表后，数据库自增的id可能会重复，雪花算法生成19位数字不重复，每毫秒可以生成4096个不重复的数（MyBatisPlus默认就是雪花算法，也可以使用@TableId（type = IdType.ASSIGN_ID））

**为什么分表**

当数据库数据达到500万条时，数据库的效率就会变慢

## 5)文章同步到app端

使用FreeMarker生成静态页面并上传到MinIO中

### 需求：当文章审核通过后，生成文章详情的静态HTML

1. **使用方法：**查看查看App端文章查看的**页面静态化集成MinIO**

## 6)模块优化

当一个请求中调用的其他服务，如果其他服务不返回结果当前服务需要等待，所以我们使用异步调用可以提高效率，用户可以进行其他操作 

### 需求：异步调用

1. 创建一个线程池并交个Spring管理

   ```java
   @Configuration
   @EnableAsync//开启异步调用
   public class ThreadPoolConfig {
   
       private static final int corePoolSize = 10;   // 核心线程数（默认线程数）
       private static final int maxPoolSize = 100;   // 最大线程数
       private static final int keepAliveTime = 10;  // 允许线程空闲时间（单位：默认为秒）
       private static final int queueCapacity = 500; // 缓冲队列数
   
       /**
        * 默认异步线程池
        * @return
        */
       @Bean("taskExecutor")
       public ThreadPoolTaskExecutor taskExecutor(){
           ThreadPoolTaskExecutor pool = new ThreadPoolTaskExecutor();
           pool.setThreadNamePrefix(".............全局线程池..............");
           pool.setCorePoolSize(corePoolSize);
           pool.setMaxPoolSize(maxPoolSize);
           pool.setKeepAliveSeconds(keepAliveTime);
           pool.setQueueCapacity(queueCapacity);
           // 直接在execute方法的调用线程中运行
           pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
           pool.initialize();//初始化线程池
           return pool;
       }
   }
   ```

2. 在服务调用方法的方法上添加

   ```java
   // 表示异步调用
   @Async("taskExecutor")//线程池的名称
   ```

   